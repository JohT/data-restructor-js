{"mappings":"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","sources":["<anon>","src/js/datarestructor.js","lib/js/flattenToArray.js","src/js/templateResolver.js","src/js/describedfield.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirec1f2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirec1f2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"keJ9m\", function(module, exports) {\n/**\n * @file datarestructor transforms parsed JSON objects into a uniform data structure\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n */ \"use strict\";\nvar $ebb82346238f20d7$var$module = $ebb82346238f20d7$var$datarestructorInternalCreateIfNotExists($ebb82346238f20d7$var$module); // Fallback for vanilla js without modules\nfunction $ebb82346238f20d7$var$datarestructorInternalCreateIfNotExists(objectToCheck) {\n    return objectToCheck || {};\n}\n/**\n * datarestructor namespace and module declaration.\n * It contains all functions to convert an object (e.g. parsed JSON) into uniform enumerated list of described field entries.\n * \n * <b>Transformation steps:</b>\n * - JSON\n * - flatten\n * - mark and identify\n * - add array fields\n * - deduplicate \n * - group\n * - flatten again\n * @module datarestructor\n */ var $ebb82346238f20d7$var$datarestructor = $ebb82346238f20d7$var$module.exports = {}; // Export module for npm...\n$ebb82346238f20d7$var$datarestructor.internalCreateIfNotExists = $ebb82346238f20d7$var$datarestructorInternalCreateIfNotExists;\n\nvar $ebb82346238f20d7$var$internal_object_tools = $ebb82346238f20d7$var$internal_object_tools || (parcelRequire(\"ccQZb\")); // supports vanilla js & npm\n\nvar $ebb82346238f20d7$var$template_resolver = $ebb82346238f20d7$var$template_resolver || (parcelRequire(\"ds403\")); // supports vanilla js & npm\n\nvar $ebb82346238f20d7$var$described_field = $ebb82346238f20d7$var$described_field || (parcelRequire(\"aJuQy\")); // supports vanilla js & npm\n/**\n * Takes the full qualified original property name and extracts a simple name out of it.\n * \n * @callback module:datarestructor.propertyNameFunction\n * @param {string} propertyName full qualified, point separated property name \n * @return {String} extracted, simple name\n */ /**\n * Describes a selected part of the incoming data structure and defines, \n * how the data should be transformed.\n * \n * @typedef {Object} module:datarestructor.PropertyStructureDescription\n * @property {string} type - \"\"(default). Some examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n * @property {string} category - name of the category. Default = \"\". Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {boolean} propertyPatternTemplateMode - \"false\"(default): property name needs to be equal to the pattern. \"true\" allows variables like \"{{fieldName}}\" inside the pattern.\n * @property {string} propertyPattern - property name pattern (without array indices) to match\n * @property {string} indexStartsWith - \"\"(default) matches all ids. String that needs to match the beginning of the id. E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n * @property {module:datarestructor.propertyNameFunction} getDisplayNameForPropertyName - display name for the property. \"\"(default) last property name element with upper case first letter.\n * @property {module:datarestructor.propertyNameFunction} getFieldNameForPropertyName - field name for the property. \"\" (default) last property name element.\n * @property {string} groupName - name of the property, that contains grouped entries. Default=\"group\".\n * @property {string} groupPattern - Pattern that describes how to group entries. \"groupName\" defines the name of this group. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationPattern - Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationName - (default=groupName) Name of the group when it had been moved to the destination.\n * @property {string} deduplicationPattern - Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n */ $ebb82346238f20d7$var$datarestructor.PropertyStructureDescriptionBuilder = function() {\n    \"use strict\";\n    /**\n   * Builder for a {@link PropertyStructureDescription}.\n   * @constructs PropertyStructureDescriptionBuilder\n   * @alias module:datarestructor.PropertyStructureDescriptionBuilder\n   */ function PropertyStructureDescription() {\n        /**\n     * @type {module:datarestructor.PropertyStructureDescription}\n     */ this.description = {\n            type: \"\",\n            category: \"\",\n            abbreviation: \"\",\n            image: \"\",\n            propertyPatternTemplateMode: false,\n            propertyPattern: \"\",\n            indexStartsWith: \"\",\n            groupName: \"group\",\n            groupPattern: \"\",\n            groupDestinationPattern: \"\",\n            groupDestinationName: null,\n            deduplicationPattern: \"\",\n            getDisplayNameForPropertyName: null,\n            getFieldNameForPropertyName: null,\n            matchesPropertyName: null\n        };\n        /**\n     * Sets the type.\n     * \n     * Contains the type of the entry, for example: \n     * - \"summary\" for e.g. a list overview. \n     * - \"detail\" e.g. when a summary is selected. \n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example type(\"summary\")\n     */ this.type = function(value) {\n            this.description.type = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the category.\n     * \n     * Contains a short domain nam, for example: \n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example category(\"Product\")\n     */ this.category = function(value) {\n            this.description.category = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the optional abbreviation.\n     * \n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example abbreviation(\"P\")\n     */ this.abbreviation = function(value) {\n            this.description.abbreviation = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the optional path to an image resource.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example image(\"img/product.png\")\n     */ this.image = function(value) {\n            this.description.image = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets \"equal mode\" for the property pattern.\n     * \n     * \"propertyPattern\" need to match exactly if this mode is activated.\n     *  It clears propertyPatternTemplateMode which means \"equal\" mode.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */ this.propertyPatternEqualMode = function() {\n            this.description.propertyPatternTemplateMode = false;\n            return this;\n        };\n        /**\n     * Sets \"template mode\" for the property pattern.\n     * \n     * \"propertyPattern\" can contain variables like {{fieldName}} and\n     * doesn't need to match the property name exactly. If the \"propertyPattern\"\n     * is shorter than the property name, it also matches when the property name\n     * starts with the \"propertyPattern\".\n     * \n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */ this.propertyPatternTemplateMode = function() {\n            this.description.propertyPatternTemplateMode = true;\n            return this;\n        };\n        /**\n     * Sets the property name pattern. \n     * \n     * Contains single property names with sub types separated by \".\" without array indices.\n     * May contain variables in double curly brackets.\n     * \n     * Example: \n     * - responses.hits.hits._source.{{fieldName}}\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n     */ this.propertyPattern = function(value) {\n            this.description.propertyPattern = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the optional beginning of the id that needs to match.\n     * Matches all indices if set to \"\" (or not called).\n     * \n     * For example:\n     * - \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example indexStartsWith(\"1.\")\n     */ this.indexStartsWith = function(value) {\n            this.description.indexStartsWith = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Overrides the display name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name starting with an upper case character.\n     *  \n     * For example:\n     * - \"Product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example displayPropertyName(\"Product\")\n     */ this.displayPropertyName = function(value) {\n            this.description.getDisplayNameForPropertyName = createNameExtractFunction(value, this.description);\n            if (isSpecifiedString(value)) return this;\n            this.description.getDisplayNameForPropertyName = removeArrayValuePropertyPostfixFunction(this.description.getDisplayNameForPropertyName);\n            this.description.getDisplayNameForPropertyName = upperCaseFirstLetterForFunction(this.description.getDisplayNameForPropertyName);\n            return this;\n        };\n        /**\n     * Overrides the (technical) field name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name.\n     *  \n     * For example:\n     * - \"product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example fieldName(\"product\")\n     */ this.fieldName = function(value) {\n            this.description.getFieldNameForPropertyName = createNameExtractFunction(value, this.description);\n            return this;\n        };\n        /**\n     * Sets the name of the property, that contains grouped entries. \n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupName(\"details\")\n     */ this.groupName = function(value) {\n            this.description.groupName = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the pattern that describes how to group entries. \n     * \n     * \"groupName\" defines the name of this group.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupPattern(\"{{type}}-{{category}}\")\n     */ this.groupPattern = function(value) {\n            this.description.groupPattern = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the pattern that describes where the group should be moved to. \n     * \n     * Default=\"\"=Group will not be moved.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"main-{{category}}\")\n     */ this.groupDestinationPattern = function(value) {\n            this.description.groupDestinationPattern = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the name of the group when it had been moved to the destination.\n     * \n     * The default value is the groupName, which will be used when the value is not valid (null or empty)\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"options\")\n     */ this.groupDestinationName = function(value) {\n            this.description.groupDestinationName = withDefault(value, this.description.groupName);\n            return this;\n        };\n        /**\n     * Sets the pattern to be used to remove duplicate entries. \n     * \n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n     */ this.deduplicationPattern = function(value) {\n            this.description.deduplicationPattern = withDefault(value, \"\");\n            return this;\n        };\n        /**\n     * Finalizes the settings and builds the  PropertyStructureDescription.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */ this.build = function() {\n            this.description.matchesPropertyName = createFunctionMatchesPropertyName(this.description);\n            if (this.description.getDisplayNameForPropertyName == null) this.displayPropertyName(\"\");\n            if (this.description.getFieldNameForPropertyName == null) this.fieldName(\"\");\n            if (this.description.groupDestinationName == null) this.groupDestinationName(\"\");\n            return this.description;\n        };\n    }\n    function createNameExtractFunction(value, description) {\n        if (isSpecifiedString(value)) return function() {\n            return value;\n        };\n        if (description.propertyPatternTemplateMode) {\n            var patternToMatch = description.propertyPattern; // closure (closed over) parameter\n            return extractNameUsingTemplatePattern(patternToMatch);\n        }\n        return extractNameUsingRightMostPropertyNameElement();\n    }\n    function createFunctionMatchesPropertyName(description) {\n        var propertyPatternToMatch = description.propertyPattern; // closure (closed over) parameter\n        if (!isSpecifiedString(propertyPatternToMatch)) return function() {\n            return false; // Without a propertyPattern, no property will match (deactivated mark/identify).\n        };\n        if (description.propertyPatternTemplateMode) return function(propertyNameWithoutArrayIndices) {\n            return templateModePatternRegexForPattern(propertyPatternToMatch).exec(propertyNameWithoutArrayIndices) != null;\n        };\n        return function(propertyNameWithoutArrayIndices) {\n            return propertyNameWithoutArrayIndices === propertyPatternToMatch;\n        };\n    }\n    function rightMostPropertyNameElement(propertyName) {\n        var regularExpression = new RegExp(\"(\\\\w+)$\", \"gi\");\n        var match = propertyName.match(regularExpression);\n        if (match != null) return match[0];\n        return propertyName;\n    }\n    function upperCaseFirstLetter(value) {\n        if (value.length > 1) return value.charAt(0).toUpperCase() + value.slice(1);\n        return value;\n    }\n    function upperCaseFirstLetterForFunction(nameExtractFunction) {\n        return function(propertyName) {\n            return upperCaseFirstLetter(nameExtractFunction(propertyName));\n        };\n    }\n    function removeArrayValuePropertyPostfixFunction(nameExtractFunction) {\n        return function(propertyName) {\n            var name = nameExtractFunction(propertyName);\n            name = name != null ? name : \"\";\n            return name.replace(\"_comma_separated_values\", \"\");\n        };\n    }\n    function extractNameUsingTemplatePattern(propertyPattern) {\n        return function(propertyName) {\n            var regex = templateModePatternRegexForPatternAndVariable(propertyPattern, \"{{fieldName}}\");\n            var match = regex.exec(propertyName);\n            if (match && match[1] != \"\") return match[1];\n            return rightMostPropertyNameElement(propertyName);\n        };\n    }\n    function extractNameUsingRightMostPropertyNameElement() {\n        return function(propertyName) {\n            return rightMostPropertyNameElement(propertyName);\n        };\n    }\n    function templateModePatternRegexForPattern(propertyPatternToUse) {\n        var placeholderInDoubleCurlyBracketsRegEx = new RegExp(\"\\\\\\\\\\\\{\\\\\\\\\\\\{[-\\\\w]+\\\\\\\\\\\\}\\\\\\\\\\\\}\", \"gi\");\n        return templateModePatternRegexForPatternAndVariable(propertyPatternToUse, placeholderInDoubleCurlyBracketsRegEx);\n    }\n    function templateModePatternRegexForPatternAndVariable(propertyPatternToUse, variablePattern) {\n        var pattern = escapeCharsForRegEx(propertyPatternToUse);\n        if (typeof variablePattern === \"string\") variablePattern = escapeCharsForRegEx(variablePattern);\n        pattern = pattern.replace(variablePattern, \"([-\\\\w]+)\");\n        pattern = \"^\" + pattern;\n        return new RegExp(pattern, \"i\");\n    }\n    function escapeCharsForRegEx(characters) {\n        var nonWordCharactersRegEx = new RegExp(\"([^-\\\\w])\", \"gi\");\n        return characters.replace(nonWordCharactersRegEx, \"\\\\$1\");\n    }\n    function withDefault(value, defaultValue) {\n        return isSpecifiedString(value) ? value : defaultValue;\n    }\n    function isSpecifiedString(value) {\n        return typeof value === \"string\" && value != null && value != \"\";\n    }\n    return PropertyStructureDescription;\n}();\n/**\n * Adds a group item/entry to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntryFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n */ /**\n * Adds some group items/entries to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntriesFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry[]} describedEntry entries that should be added to the group\n */ /**\n * @typedef {Object} module:datarestructor.DescribedEntry\n * @property {string} category - category of the result from the PropertyStructureDescription using a short name or e.g. a symbol character\n * @property {string} type - type of the result from PropertyStructureDescription\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the split index. Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with the two elements: [2,4]\n * @property {string} displayName - display name extracted from the point separated hierarchical property name, e.g. \"Name\"\n * @property {string} fieldName - field name extracted from the point separated hierarchical property name, e.g. \"name\"\n * @property {string} value - content of the field\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {module:datarestructor.addGroupEntryFunction} addGroupEntry - function, that adds an entry to the given group. If the group does not exist, it will be created.\n * @property {module:datarestructor.addGroupEntriesFunction} addGroupEntries - function, that adds entries to the given group. If the group does not exist, it will be created.\n * @property {boolean} _isMatchingIndex - true, when _identifier.index matches the described \"indexStartsWith\"\n * @property {Object} _identifier - internal structure for identifier. Avoid using it outside since it may change.\n * @property {string} _identifier.index - array indices in hierarchical order separated by points, e.g. \"0.0\"\n * @property {string} _identifier.value - the (single) value of the \"flattened\" property, e.g. \"Smith\"\n * @property {string} _identifier.propertyNameWithArrayIndices - the \"original\" flattened property name in hierarchical order separated by points, e.g. \"responses[0].hits.hits[0]._source.name\"\n * @property {string} _identifier.propertyNameWithoutArrayIndices - same as propertyNamesWithArrayIndices but without array indices, e.g. \"responses.hits.hits._source.name\"\n * @property {string} _identifier.groupId - Contains the resolved groupPattern from the PropertyStructureDescription. Entries with the same id will be grouped into the \"groupName\" of the PropertyStructureDescription.\n * @property {string} _identifier.groupDestinationId - Contains the resolved groupDestinationPattern from the PropertyStructureDescription. Entries with this id will be moved to the given destination group.\n * @property {string} _identifier.deduplicationId - Contains the resolved deduplicationPattern from the PropertyStructureDescription. Entries with the same id will be considered to be a duplicate and hence removed.\n * @property {Object} _description - PropertyStructureDescription for internal use. Avoid using it outside since it may change.\n */ /**\n * Returns a field value of the given {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.stringFieldOfDescribedEntryFunction\n * @param {module:datarestructor.DescribedEntry} entry described entry that contains the field that should be returned\n * @returns {String} field value \n */ $ebb82346238f20d7$var$datarestructor.DescribedEntryCreator = function() {\n    \"use strict\";\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    /**\n   * Creates a {@link module:datarestructor.DescribedEntry}.\n   * @constructs DescribedEntryCreator\n   * @alias module:datarestructor.DescribedEntryCreator\n   */ function DescribedEntry(entry, description) {\n        var indices = indicesOf(entry.name);\n        var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n        var templateResolver = new $ebb82346238f20d7$var$template_resolver.Resolver(this);\n        this.category = description.category;\n        this.type = description.type;\n        this.abbreviation = description.abbreviation;\n        this.image = description.image;\n        /**\n     * Array of numbers containing the split index.\n     * Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with two elements: [2,4]\n     * This is the public version of the internal variable _identifier.index, which contains in contrast all index elements in one point separated string (e.g. \"2.4\").\n     * @type {number[]}\n     */ this.index = indices.numberArray;\n        this.displayName = description.getDisplayNameForPropertyName(propertyNameWithoutArrayIndices);\n        this.fieldName = description.getFieldNameForPropertyName(propertyNameWithoutArrayIndices);\n        this.value = entry.value;\n        this.groupNames = [];\n        this._isMatchingIndex = indices.pointDelimited.indexOf(description.indexStartsWith) == 0;\n        this._description = description;\n        this._identifier = {\n            index: indices.pointDelimited,\n            propertyNameWithArrayIndices: entry.name,\n            propertyNameWithoutArrayIndices: propertyNameWithoutArrayIndices,\n            groupId: \"\",\n            groupDestinationId: \"\",\n            deduplicationId: \"\"\n        };\n        this._identifier.groupId = templateResolver.replaceResolvableFields(description.groupPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n        this._identifier.groupDestinationId = templateResolver.replaceResolvableFields(description.groupDestinationPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n        this._identifier.deduplicationId = templateResolver.replaceResolvableFields(description.deduplicationPattern, templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier));\n        /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName name of the group that should be added\n     * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n     */ this.addGroupEntry = function(groupName, describedEntry) {\n            this.addGroupEntries(groupName, [\n                describedEntry\n            ]);\n        };\n        /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName\n     * @param {module:datarestructor.DescribedEntry[]} describedEntries\n     */ this.addGroupEntries = function(groupName, describedEntries) {\n            if (!this[groupName]) {\n                this.groupNames.push(groupName);\n                this[groupName] = [];\n            }\n            var index;\n            var describedEntry;\n            for(index = 0; index < describedEntries.length; index += 1){\n                describedEntry = describedEntries[index];\n                this[groupName].push(describedEntry);\n            }\n        };\n    }\n    /**\n   * @typedef {Object} module:datarestructor.ExtractedIndices\n   * @property {string} pointDelimited - bracket indices separated by points\n   * @property {number[]} numberArray as array of numbers\n   */ /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {String} fullPropertyName\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */ function indicesOf(fullPropertyName) {\n        var arrayBracketsRegEx = new RegExp(\"\\\\[(\\\\d+)\\\\]\", \"gi\");\n        return indicesOfWithRegex(fullPropertyName, arrayBracketsRegEx);\n    }\n    /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {string} fullPropertyName\n   * @param {RegExp} regexWithOneNumberGroup\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */ function indicesOfWithRegex(fullPropertyName, regexWithOneNumberGroup) {\n        var pointDelimited = \"\";\n        var numberArray = [];\n        var match;\n        do {\n            match = regexWithOneNumberGroup.exec(fullPropertyName);\n            if (match) {\n                if (pointDelimited.length > 0) pointDelimited += \".\";\n                pointDelimited += match[1];\n                numberArray.push(parseInt(match[1]));\n            }\n        }while (match);\n        return {\n            pointDelimited: pointDelimited,\n            numberArray: numberArray\n        };\n    }\n    return DescribedEntry;\n}();\n/**\n   * @typedef {Object} module:datarestructor.TransformConfig\n   * @property {boolean} debugMode enables/disables detailed logging\n   * @property {number} [maxRecursionDepth=8] Maximum recursion depth\n   * @property {number} [removeDuplicationAboveRecursionDepth=1]  Duplications will be removed above the given recursion depth value and remain unchanged below it.\n   */ $ebb82346238f20d7$var$datarestructor.Transform = function() {\n    \"use strict\";\n    /**\n   * Main class for the data transformation.\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions\n   * @constructs Transform\n   * @alias module:datarestructor.Transform\n   */ function Transform(descriptions) {\n        /**\n     * Descriptions of the input data that define the behaviour of the transformation.\n     * @type {module:datarestructor.DescribedEntry[]}\n     */ this.descriptions = descriptions;\n        /**\n     * Configuration for the transformation.\n     * @protected\n     * @type {module:datarestructor.TransformConfig}\n     */ this.config = {\n            /**\n       * Debug mode switch, that enables/disables detailed logging.\n       * @protected\n       * @type {boolean}\n       */ debugMode: false,\n            /**\n       * Maximum recursion depth. Defaults to 8.\n       * @protected\n       * @type {number}\n       */ maxRecursionDepth: 8,\n            /**\n       * Duplications will be removed above the given recursion depth and remain below it.\n       * Defaults to 1.\n       *\n       * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n       * data structures are possible by nature and will lead to duplications. Some of them\n       * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n       * To restrict duplications and improve performance it is beneficial to define a\n       * recursion depth, above which further duplication won't be used and should be removed/avoided.\n       *\n       * @protected\n       * @type {number}\n       */ removeDuplicationAboveRecursionDepth: 1\n        };\n        /**\n     * Enables debug mode. Logs additional information.\n     * @returns {module:datarestructor.Transform}\n     */ this.enableDebugMode = function() {\n            this.config.debugMode = true;\n            return this;\n        };\n        /**\n     * Sets the maximum recursion depth. Defaults to 8 if not set.\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */ this.setMaxRecursionDepth = function(value) {\n            if (typeof value !== \"number\" || value < 0) throw \"Invalid max recursion depth value: \" + value;\n            this.config.maxRecursionDepth = value;\n            return this;\n        };\n        /**\n     * Sets the recursion depth above which duplication will be removed. Duplications below it remain unchanged.\n     * Defaults to 1.\n     *\n     * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n     * data structures are possible by nature and will lead to duplications. Some of them\n     * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n     * To restrict duplications and improve performance it is beneficial to define a\n     * recursion depth, above which further duplication won't be used and should be removed/avoided.\n     *\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */ this.setRemoveDuplicationAboveRecursionDepth = function(value) {\n            if (typeof value !== \"number\" || value < 0) throw \"Invalid remove duplications above recursion depth value: \" + value;\n            this.config.removeDuplicationAboveRecursionDepth = value;\n            return this;\n        };\n        /**\n     * \"Assembly line\", that takes the (pared JSON) data and processes it using all given descriptions in their given order.\n     * @param {object} data - parsed JSON data or any other data object\n     * @returns {module:datarestructor.DescribedEntry[]}\n     * @example\n     * var allDescriptions = [];\n     * allDescriptions.push(summariesDescription());\n     * allDescriptions.push(detailsDescription());\n     * var result = new datarestructor.Transform(allDescriptions).processJson(jsonData);\n     */ this.processJson = function(data) {\n            return processJsonUsingDescriptions(data, this.descriptions, this.config);\n        };\n    }\n    /**\n   * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n   * @param {object} jsonData parsed JSON data or any other data object\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function processJsonUsingDescriptions(jsonData, descriptions, config) {\n        // \"Flatten\" the hierarchical input json to an array of property names (point separated \"folders\") and values.\n        var processedData = $ebb82346238f20d7$var$internal_object_tools.flattenToArray(jsonData);\n        // Fill in properties ending with the name \"_comma_separated_values\" for array values to make it easier to display them.\n        processedData = fillInArrayValues(processedData);\n        if (config.debugMode) {\n            console.log(\"flattened data with array values:\");\n            console.log(processedData);\n        }\n        // Mark, identify and harmonize the flattened data by applying one description after another in their given order.\n        var describedData = [];\n        var descriptionIndex, description, dataWithDescription;\n        for(descriptionIndex = 0; descriptionIndex < descriptions.length; descriptionIndex += 1){\n            description = descriptions[descriptionIndex];\n            // Filter all entries that match the current description and enrich them with it\n            dataWithDescription = extractEntriesByDescription(processedData, description);\n            // Remove duplicate entries where a deduplicationPattern is described\n            describedData = deduplicateFlattenedData(describedData, dataWithDescription);\n        }\n        processedData = describedData;\n        if (config.debugMode) {\n            console.log(\"describedData data:\");\n            console.log(processedData);\n        }\n        // Group entries where a groupPattern is described\n        processedData = groupFlattenedData(processedData);\n        if (config.debugMode) {\n            console.log(\"grouped describedData data:\");\n            console.log(processedData);\n        }\n        // Move group entries where a groupDestinationPattern is described\n        processedData = applyGroupDestinationPattern(processedData);\n        if (config.debugMode) {\n            console.log(\"moved grouped describedData data:\");\n            console.log(processedData);\n        }\n        // Turns the grouped object back into an array of DescribedEntry-Objects\n        processedData = propertiesAsArray(processedData);\n        // Converts the internal described entries  into described fields\n        processedData = toDescribedFields(processedData, config);\n        if (config.debugMode) {\n            console.log(\"transformed result:\");\n            console.log(processedData);\n        }\n        return processedData;\n    }\n    /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries that occur later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * The id is extracted from every element using the given function.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function mergeFlattenedData(entries, entriesToMerge, idOfElementFunction) {\n        var entriesToMergeById = asIdBasedObject(entriesToMerge, idOfElementFunction);\n        var merged = [];\n        var index, entry, id;\n        for(index = 0; index < entries.length; index += 1){\n            entry = entries[index];\n            id = idOfElementFunction(entry);\n            if (id == null || id === \"\" || entriesToMergeById[id] == null) merged.push(entry);\n        }\n        for(index = 0; index < entriesToMerge.length; index += 1){\n            entry = entriesToMerge[index];\n            merged.push(entry);\n        }\n        return merged;\n    }\n    /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries occurring later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * \"entriesToMerge\" will be returned directly, if \"entries\" is null or empty.\n   *\n   * The id is extracted from every element using their deduplication pattern (if available).\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @see mergeFlattenedData\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function deduplicateFlattenedData(entries, entriesToMerge) {\n        if (entries == null || entries.length == 0) return entriesToMerge;\n        var idOfElementFunction = function(entry) {\n            return entry._identifier.deduplicationId;\n        };\n        return mergeFlattenedData(entries, entriesToMerge, idOfElementFunction);\n    }\n    /**\n   * Converts the given elements to an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1.\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function asIdBasedObject(elements, idOfElementFunction) {\n        var idIndexedObject = new Object();\n        for(var index = 0; index < elements.length; index++){\n            var element = elements[index];\n            idIndexedObject[idOfElementFunction(element)] = element;\n        }\n        return idIndexedObject;\n    }\n    /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id (determined by the entry's groupPattern).\n   * For example, [{id: A, value: 1}] becomes result['A'] = 1.\n   *\n   * Furthermore, this function creates a group property (determined by the entry's groupName)\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function groupFlattenedData(flattenedData) {\n        return groupById(flattenedData, function(entry) {\n            return entry._identifier.groupId;\n        }, function(entry) {\n            return entry._description.groupName;\n        });\n    }\n    /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1. Furthermore, this function creates a group property (with the name )\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupNameOfElementFunction function, that returns the name of the group property that will be created inside the \"main\" element.\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupIdOfElementFunction returns the group id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function groupById(elements, groupIdOfElementFunction, groupNameOfElementFunction) {\n        var groupedResult = new Object();\n        for(var index = 0; index < elements.length; index++){\n            var element = elements[index];\n            var groupId = groupIdOfElementFunction(element);\n            if (groupId === \"\") continue;\n            var groupName = groupNameOfElementFunction(element);\n            if (groupName == null || groupName === \"\") continue;\n            if (!groupedResult[groupId]) groupedResult[groupId] = element;\n            groupedResult[groupId].addGroupEntry(groupName, element);\n        }\n        return groupedResult;\n    }\n    /**\n   * Extracts entries out of \"flattened\" JSON data and provides an array of objects.\n   * @param {Object[]} flattenedData - flattened json from search query result\n   * @param {string} flattenedData[].name - name of the property in hierarchical order separated by points\n   * @param {string} flattenedData[].value - value of the property as string\n   * @param {module:datarestructor.PropertyStructureDescription} - description of structure of the entries that should be extracted\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function extractEntriesByDescription(flattenedData, description) {\n        var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n        var filtered = [];\n        flattenedData.filter(function(entry) {\n            var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n            if (description.matchesPropertyName(propertyNameWithoutArrayIndices)) {\n                var describedEntry = new $ebb82346238f20d7$var$datarestructor.DescribedEntryCreator(entry, description);\n                if (describedEntry._isMatchingIndex) filtered.push(describedEntry);\n            }\n        });\n        return filtered;\n    }\n    /**\n   * Takes already grouped {@link module:datarestructor.DescribedEntry} objects and\n   * uses their \"_identifier.groupDestinationId\" (if exists)\n   * to move groups to the given destination.\n   *\n   * This is useful, if separately described groups like \"summary\" and \"detail\" should be put together,\n   * so that every summery contains a group with the regarding details.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} groupedObject - already grouped entries\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function applyGroupDestinationPattern(groupedObject) {\n        var keys = Object.keys(groupedObject);\n        var keysToDelete = [];\n        for(var index = 0; index < keys.length; index++){\n            var key = keys[index];\n            var entry = groupedObject[key];\n            if (entry._description.groupDestinationPattern != \"\") {\n                var destinationKey = entry._identifier.groupDestinationId;\n                if (groupedObject[destinationKey] != null) {\n                    var newGroup = entry[entry._description.groupName];\n                    groupedObject[destinationKey].addGroupEntries(entry._description.groupDestinationName, newGroup);\n                    keysToDelete.push(key);\n                }\n            }\n        }\n        // delete all moved entries that had been collected by their key\n        for(index = 0; index < keysToDelete.length; index += 1){\n            var keyToDelete = keysToDelete[index];\n            delete groupedObject[keyToDelete];\n        }\n        return groupedObject;\n    }\n    /**\n   * Fills in extra \"_comma_separated_values\" properties into the flattened data\n   * for properties that end with an array. E.g. response.hits.hits.tags[0]=\"active\" and response.hits.hits.tags[0]=\"ready\"\n   * will lead to the extra element \"response.hits.hits.tags_comma_separated_values=\"active, ready\".\n   *\n   * @return flattened data with filled in \"_comma_separated_values\" properties\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function fillInArrayValues(flattenedData) {\n        var trailingArrayIndexRegEx = new RegExp(\"\\\\[\\\\d+\\\\]$\", \"gi\");\n        var result = [];\n        var lastArrayProperty = \"\";\n        var lastArrayPropertyValue = \"\";\n        flattenedData.filter(function(entry) {\n            if (!entry.name.match(trailingArrayIndexRegEx)) {\n                if (lastArrayProperty !== \"\") {\n                    result.push({\n                        name: lastArrayProperty + \"_comma_separated_values\",\n                        value: lastArrayPropertyValue\n                    });\n                    lastArrayProperty = \"\";\n                }\n                result.push(entry);\n                return;\n            }\n            var propertyNameWithoutTrailingArrayIndex = entry.name.replace(trailingArrayIndexRegEx, \"\");\n            if (lastArrayProperty === propertyNameWithoutTrailingArrayIndex) lastArrayPropertyValue += \", \" + entry.value;\n            else {\n                if (lastArrayProperty !== \"\") {\n                    result.push({\n                        name: lastArrayProperty + \"_comma_separated_values\",\n                        value: lastArrayPropertyValue\n                    });\n                    lastArrayProperty = \"\";\n                }\n                lastArrayProperty = propertyNameWithoutTrailingArrayIndex;\n                lastArrayPropertyValue = entry.value;\n            }\n            result.push(entry);\n        });\n        return result;\n    }\n    function propertiesAsArray(groupedData) {\n        var result = [];\n        var propertyNames = Object.keys(groupedData);\n        for(var propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex++){\n            var propertyName = propertyNames[propertyIndex];\n            var propertyValue = groupedData[propertyName];\n            result.push(propertyValue);\n        }\n        return result;\n    }\n    /**\n   * Converts described entries (internal data structure) to described fields (external data structure).\n   * Since the structure of a described field is hierarchical, every field needs to be converted\n   * in a recursive manner. The maximum recursion depth is taken as the second parameter.\n   * @param {module:datarestructor.DescribedEntry[]} describedEntries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:described_field.DescribedDataField[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function toDescribedFields(describedEntries, config) {\n        var result = [];\n        var index;\n        var describedEntity;\n        for(index = 0; index < describedEntries.length; index += 1){\n            describedEntity = describedEntries[index];\n            result.push(toDescribedField(describedEntity, {\n                recursionDepth: 0,\n                config: config,\n                groupToSkip: \"\"\n            }));\n        }\n        return result;\n    }\n    /**\n   * Describes the context type for the recursive DescribedDataField conversion,\n   * that contains everything that needs to be accessible throughout recursion regardless of the\n   * recursion depth.\n   *\n   * @typedef {Object} module:datarestructor.DescribedFieldRecursionContext\n   * @param {number} recursionDepth current recursion depth\n   * @param {String} groupToSkip name of a group to skip or \"\" when no group should be skipped. \n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   */ /**\n   * Converts a internal described entry to a newly created public described field.\n   * Since the structure of a described field is hierarchical, this function is called recursively.\n   * Because the internal described entries may very likely contain cyclic references, the depth of recursion\n   * needs to be limited. Therefore, the current recursion depth is taken as second parameter\n   * and the maximum recursion depth is taken as third parameter.\n   * @param {module:datarestructor.DescribedEntry} entry the internal entry that will be converted\n   * @param {module:datarestructor.DescribedFieldRecursionContext} recursionContext context contains everything that needs to be accessible throughout the recursion.\n   * @returns {module:described_field.DescribedDataField}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function toDescribedField(entry, recursionContext) {\n        var field = new $ebb82346238f20d7$var$described_field.DescribedDataFieldBuilder().category(entry.category).type(entry.type).abbreviation(entry.abbreviation).image(entry.image).index(entry.index).displayName(entry.displayName).fieldName(entry.fieldName).value(entry.value).build();\n        if (recursionContext.recursionDepth > recursionContext.config.maxRecursionDepth) return field;\n        var nextRecursionContext = null;\n        var duplicateGroupNameToSkip = \"\";\n        var fieldGroups = new $ebb82346238f20d7$var$described_field.DescribedDataFieldGroup(field);\n        forEachGroupEntry(entry, function(groupName, groupEntry, allGroupEntries) {\n            if (recursionContext.groupToSkip === groupName) {\n                if (recursionContext.config.debugMode) console.log(\"Removed duplicate group \" + groupName + \" at recursion depth \" + recursionContext.recursionDepth);\n                return;\n            }\n            duplicateGroupNameToSkip = \"\";\n            if (recursionContext.recursionDepth >= recursionContext.config.removeDuplicationAboveRecursionDepth) duplicateGroupNameToSkip = arraysEqual(groupEntry[groupName], allGroupEntries, describedFieldEqual) ? groupName : \"\";\n            nextRecursionContext = {\n                recursionDepth: recursionContext.recursionDepth + 1,\n                config: recursionContext.config,\n                groupToSkip: duplicateGroupNameToSkip\n            };\n            fieldGroups.addGroupEntry(groupName, toDescribedField(groupEntry, nextRecursionContext));\n        });\n        return field;\n    }\n    function describedFieldEqual(a, b) {\n        return defaultEmpty(a.category) === defaultEmpty(b.category) && defaultEmpty(a.type) === defaultEmpty(b.type) && a.fieldName === b.fieldName && a.value === b.value;\n    }\n    function defaultEmpty(value) {\n        return defaultValue(value, \"\");\n    }\n    function defaultValue(value, valueAsDefault) {\n        if (typeof value === \"undefined\" || !value) return valueAsDefault;\n        return value;\n    }\n    // Reference: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript/16430730\n    // Added \"elementEqualFunction\" to implement equal object detection.\n    // Arrays are assumed to be sorted. Differently ordered entries are treated as not equal.\n    function arraysEqual(a, b, elementEqualFunction) {\n        if (a === b) return true;\n        if (a == null || b == null) return false;\n        if (a.length !== b.length) return false;\n        for(var i = 0; i < a.length; ++i){\n            if (!elementEqualFunction(a[i], b[i])) return false;\n        }\n        return true;\n    }\n    /**\n   * Takes the full qualified original property name and extracts a simple name out of it.\n   *\n   * @callback module:datarestructor.onEntryFoundFunction\n   * @param {string} groupName name of the group where the entry had been found.\n   * @param {module:datarestructor.DescribedEntry} foundEntry the found entry itself.\n   * @param {module:datarestructor.DescribedEntry[]} allEntries the array of all entries where the found entry is an element of.\n   */ /**\n   * Traverses through all groups and their entries and calls the given function on every found entry\n   * with the group name and the entry itself as parameters.\n   * @param {module:datarestructor.DescribedEntry} rootEntry\n   * @param {module:datarestructor.onEntryFoundFunction} onFoundEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */ function forEachGroupEntry(rootEntry, onFoundEntry) {\n        var groupIndex, entryIndex;\n        var groupName, entry;\n        for(groupIndex = 0; groupIndex < rootEntry.groupNames.length; groupIndex += 1){\n            groupName = rootEntry.groupNames[groupIndex];\n            for(entryIndex = 0; entryIndex < rootEntry[groupName].length; entryIndex += 1){\n                entry = rootEntry[groupName][entryIndex];\n                onFoundEntry(groupName, entry, rootEntry[groupName]);\n            }\n        }\n    }\n    return Transform;\n}();\n/**\n * Main fassade for the data restructor as static function(s).\n * \n * @example \n * var allDescriptions = [];\n * allDescriptions.push(summariesDescription());\n * allDescriptions.push(detailsDescription());\n * var result = datarestructor.Restructor.processJsonUsingDescriptions(jsonData, allDescriptions);\n * @namespace module:datarestructor.Restructor\n */ $ebb82346238f20d7$var$datarestructor.Restructor = {};\n/**\n * Static fassade function for the \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n * @param {object} jsonData - parsed JSON data or any other data object\n * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n * @returns {module:datarestructor.DescribedEntry[]}\n * @memberof module:datarestructor.Restructor\n * @deprecated since v3.1.0, please use \"new datarestructor.Transform(descriptions).processJson(jsonData)\".\n */ $ebb82346238f20d7$var$datarestructor.Restructor.processJsonUsingDescriptions = function(jsonData, descriptions, debugMode) {\n    var restructor = new $ebb82346238f20d7$var$datarestructor.Transform(descriptions);\n    if (debugMode) restructor.enableDebugMode();\n    return restructor.processJson(jsonData);\n};\n\n});\nparcelRegister(\"ccQZb\", function(module, exports) {\n\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */ var $8e2fb4eb18d4597b$var$module = $8e2fb4eb18d4597b$var$module || {}; // Fallback for vanilla js without modules\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */ var $8e2fb4eb18d4597b$var$internal_object_tools = $8e2fb4eb18d4597b$var$module.exports = {}; // Export module for npm...\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */ /**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */ $8e2fb4eb18d4597b$var$internal_object_tools.flattenToArray = function(data, maxRecursionDepth) {\n    var result = [];\n    if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) maxRecursionDepth = 20;\n    function recurse(cur, prop, depth) {\n        if (depth > maxRecursionDepth || typeof cur === \"function\") return;\n        if (Object(cur) !== cur) result.push({\n            name: prop,\n            value: cur\n        });\n        else if (Array.isArray(cur)) {\n            var i;\n            var l = cur.length;\n            for(i = 0; i < l; i += 1)recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n            if (l === 0) {\n                result[prop] = [];\n                result.push({\n                    name: prop,\n                    value: \"\"\n                });\n            }\n        } else {\n            var isEmpty = true;\n            var p;\n            for(p in cur){\n                isEmpty = false;\n                recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n            }\n            if (isEmpty && prop) result.push({\n                name: prop,\n                value: \"\"\n            });\n        }\n    }\n    recurse(data, \"\", 0);\n    return result;\n};\n\n});\n\nparcelRegister(\"ds403\", function(module, exports) {\n/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */ \"use strict\";\nvar $9cb0fe3475961b60$var$module = $9cb0fe3475961b60$var$templateResolverInternalCreateIfNotExists($9cb0fe3475961b60$var$module); // Fallback for vanilla js without modules\nfunction $9cb0fe3475961b60$var$templateResolverInternalCreateIfNotExists(objectToCheck) {\n    return objectToCheck || {};\n}\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */ var $9cb0fe3475961b60$var$template_resolver = $9cb0fe3475961b60$var$module.exports = {}; // Export module for npm...\n$9cb0fe3475961b60$var$template_resolver.internalCreateIfNotExists = $9cb0fe3475961b60$var$templateResolverInternalCreateIfNotExists;\n\nvar $9cb0fe3475961b60$var$internal_object_tools = $9cb0fe3475961b60$var$internal_object_tools || (parcelRequire(\"ccQZb\")); // supports vanilla js & npm\n$9cb0fe3475961b60$var$template_resolver.Resolver = function() {\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    /**\n   * Resolver. Is used inside this repository. It could also be used outside.\n   * @param {*} sourceDataObject The properties of this object will be used to replace the placeholders in the template.\n   * @constructs Resolver\n   * @alias module:template_resolver.Resolver\n   */ function Resolver(sourceDataObject) {\n        /**\n     * The properties of this source data object will be used to replace the placeholders in the template.\n     */ this.sourceDataObject = sourceDataObject;\n        /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */ this.resolveTemplate = function(template) {\n            return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n        };\n        /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     * @public\n     */ this.resolvableFieldsOfAll = function() {\n            var map = {};\n            var ignoreInternalFields = function(propertyName) {\n                return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n            };\n            var index;\n            for(index = 0; index < arguments.length; index += 1)addToFilteredMapObject($9cb0fe3475961b60$var$internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n            return map;\n        };\n        /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */ this.replaceResolvableFields = function(stringContainingVariables, resolvableFields) {\n            var replaced = stringContainingVariables;\n            var propertyNames = Object.keys(resolvableFields);\n            var propertyIndex = 0;\n            var propertyName = \"\";\n            var propertyValue = \"\";\n            for(propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1){\n                propertyName = propertyNames[propertyIndex];\n                propertyValue = resolvableFields[propertyName];\n                replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n            }\n            return replaced;\n        };\n    }\n    /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */ function addFieldsPerGroup(map) {\n        var propertyNames = Object.keys(map);\n        var i, fullPropertyName, propertyInfo, propertyValue;\n        for(i = 0; i < propertyNames.length; i += 1){\n            fullPropertyName = propertyNames[i];\n            propertyValue = map[fullPropertyName];\n            propertyInfo = getPropertyNameInfos(fullPropertyName);\n            // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n            // and a property named \"value\" inside the same sub object (containing its value).\n            // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n            // TODO could make \"fieldName\" and \"value\" configurable\n            if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n        }\n        return map;\n    }\n    /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */ function getPropertyNameInfos(fullPropertyName) {\n        var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n        var propertyName = fullPropertyName;\n        if (positionOfRightMostSeparator > 0) propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n        var propertyGroup = \"\";\n        if (positionOfRightMostSeparator > 0) propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n        var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n        return {\n            group: propertyGroup,\n            groupWithoutArrayIndices: propertyGroupWithoutArrayIndices,\n            name: propertyName\n        };\n    }\n    /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */ function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n        var index, element;\n        for(index = 0; index < elements.length; index += 1){\n            element = elements[index];\n            if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) mapObject[element.name] = element.value;\n        }\n        return mapObject;\n    }\n    return Resolver;\n}();\n\n});\n\nparcelRegister(\"aJuQy\", function(module, exports) {\n/**\n * @file Describes a data field of the restructured data.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */ \"use strict\";\nvar $7d0608def849b52f$var$module = $7d0608def849b52f$var$describedFieldInternalCreateIfNotExists($7d0608def849b52f$var$module); // Fallback for vanilla js without modules\nfunction $7d0608def849b52f$var$describedFieldInternalCreateIfNotExists(objectToCheck) {\n    return objectToCheck || {};\n}\n/**\n * Describes a data field of the restructured data.\n * @module described_field\n */ var $7d0608def849b52f$var$described_field = $7d0608def849b52f$var$module.exports = {}; // Export module for npm...\n$7d0608def849b52f$var$described_field.internalCreateIfNotExists = $7d0608def849b52f$var$describedFieldInternalCreateIfNotExists;\n/**\n * Describes a field of the restructured data.\n * Dynamically added properties represent custom named groups containing DescribedDataField-Arrays.\n *\n * @typedef {Object} module:described_field.DescribedDataField\n * @property {string} [category=\"\"] - name of the category. Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [type=\"\"] - type of the data element. Examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as data filters.\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the splitted index. Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4]\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {string} displayName - display name of the field\n * @property {string} fieldName - field name\n * @property {{*}} value - content of the field\n * @property {module:described_field.DescribedDataField[]} [couldBeAnyCustomGroupName] any number of groups attached to the field each containing multiple fields\n */ $7d0608def849b52f$var$described_field.DescribedDataFieldBuilder = function() {\n    /**\n   * Builds a {@link module:described_field.DescribedDataField}.\n   * DescribedDataField is the main element of the restructured data and therefore considered \"public\".\n   * @constructs DescribedDataFieldBuilder\n   * @alias module:described_field.DescribedDataFieldBuilder\n   */ function DescribedDataFieldBuilder() {\n        /**\n     * @type {module:described_field.DescribedDataField}\n     */ this.describedField = {\n            category: \"\",\n            type: \"\",\n            abbreviation: \"\",\n            image: \"\",\n            index: [],\n            groupNames: [],\n            displayName: \"\",\n            fieldName: \"\",\n            value: \"\"\n        };\n        /**\n     * Takes over all values of the template {@link module:described_field.DescribedDataField}.\n     * @function\n     * @param {module:described_field.DescribedDataField} template\n     * @returns {DescribedDataFieldBuilder}\n     * @example fromDescribedDataField(sourceField)\n     */ this.fromDescribedDataField = function(template) {\n            this.category(template.category);\n            this.type(template.type);\n            this.abbreviation(template.abbreviation);\n            this.image(template.image);\n            this.index(template.index);\n            this.groupNames(template.groupNames);\n            this.displayName(template.displayName);\n            this.fieldName(template.fieldName);\n            this.value(template.value);\n            return this;\n        };\n        /**\n     * Sets the category.\n     *\n     * Contains a short domain nam, for example:\n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example category(\"Product\")\n     */ this.category = function(value) {\n            this.describedField.category = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the type.\n     *\n     * Contains the type of the entry, for example:\n     * - \"summary\" for e.g. a list overview.\n     * - \"detail\" e.g. when a summary is selected.\n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example type(\"summary\")\n     */ this.type = function(value) {\n            this.describedField.type = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the optional abbreviation.\n     *\n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example abbreviation(\"P\")\n     */ this.abbreviation = function(value) {\n            this.describedField.abbreviation = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the optional path to an image resource.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example image(\"img/product.png\")\n     */ this.image = function(value) {\n            this.describedField.image = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the index as an array of numbers containing the splitted array indexes of the source field.\n     * Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4].\n     *\n     * @function\n     * @param {number[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example index([2,4])\n     */ this.index = function(value) {\n            this.describedField.index = withDefaultArray(value, []);\n            return this;\n        };\n        /**\n     * Sets the group names as an array of strings containing the names of the dynamically added properties,\n     * that contain an array of {@link module:described_field.DescribedDataField}-Objects.\n     *\n     * @function\n     * @param {string[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example groupNames([\"summaries\",\"details\",\"options\"])\n     */ this.groupNames = function(value) {\n            this.describedField.groupNames = withDefaultArray(value, []);\n            return this;\n        };\n        /**\n     * Sets the display name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example displayName(\"Color\")\n     */ this.displayName = function(value) {\n            this.describedField.displayName = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the (technical) field name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example fieldName(\"color\")\n     */ this.fieldName = function(value) {\n            this.describedField.fieldName = withDefaultString(value, \"\");\n            return this;\n        };\n        /**\n     * Sets the value/content of the field.\n     *\n     * @function\n     * @param {*} value\n     * @returns {DescribedDataFieldBuilder}\n     * @example value(\"darkblue\")\n     */ this.value = function(value) {\n            this.describedField.value = value;\n            return this;\n        };\n        /**\n     * Finalizes the settings and builds the {@link module:described_field.DescribedDataField}.\n     * @function\n     * @returns {module:described_field.DescribedDataField}\n     */ this.build = function() {\n            return this.describedField;\n        };\n    }\n    function isSpecifiedString(value) {\n        return typeof value === \"string\" && value !== null && value !== \"\";\n    }\n    function withDefaultString(value, defaultValue) {\n        return isSpecifiedString(value) ? value : defaultValue;\n    }\n    function withDefaultArray(value, defaultValue) {\n        return value === undefined || value === null ? defaultValue : value;\n    }\n    return DescribedDataFieldBuilder;\n}();\n/**\n * Creates a new described data field with all properties of the original one except for dynamically added groups.\n * @param {module:described_field.DescribedDataField} describedDataField\n * @returns {module:described_field.DescribedDataField}\n * @memberof module:described_field\n */ $7d0608def849b52f$var$described_field.copyWithoutGroups = function(describedDataField) {\n    return new $7d0608def849b52f$var$described_field.DescribedDataFieldBuilder().fromDescribedDataField(describedDataField).groupNames([]).build();\n};\n$7d0608def849b52f$var$described_field.DescribedDataFieldGroup = function() {\n    /**\n   * Adds groups to {@link module:described_field.DescribedDataField}s. These groups are dynamically added properties\n   * that contain an array of sub fields of the same type {@link module:described_field.DescribedDataField}s.\n   *\n   * @param {module:described_field.DescribedDataField} dataField\n   * @constructs DescribedDataFieldGroup\n   * @alias module:described_field.DescribedDataFieldGroup\n   * @example new described_field.DescribedDataFieldGroup(field).addGroupEntry(\"details\", detailField);\n   */ function DescribedDataFieldGroup(dataField) {\n        this.dataField = dataField;\n        /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entry will be added\n     * @param {module:described_field.DescribedDataField} describedField sub field that is added to the group\n     * @returns {DescribedDataFieldGroup}\n     */ this.addGroupEntry = function(groupName, describedField) {\n            this.addGroupEntries(groupName, [\n                describedField\n            ]);\n            return this;\n        };\n        /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entries will be added\n     * @param {module:described_field.DescribedDataField[]} describedFields sub fields that are added to the group\n     * @returns {DescribedDataFieldGroup}\n     */ this.addGroupEntries = function(groupName, describedFields) {\n            if (!groupName || groupName.length === 0) return this;\n            if (!describedFields || describedFields.length === 0) return this;\n            if (this.dataField[groupName] === undefined) {\n                this.dataField.groupNames.push(groupName);\n                this.dataField[groupName] = [];\n            }\n            var index;\n            var describedField;\n            for(index = 0; index < describedFields.length; index += 1){\n                describedField = describedFields[index];\n                this.dataField[groupName].push(describedField);\n            }\n            return this;\n        };\n    }\n    return DescribedDataFieldGroup;\n}();\n\n});\n\n\n\nparcelRequire(\"keJ9m\");\n\n//# sourceMappingURL=datarestructor.js.map\n","/**\n * @file datarestructor transforms parsed JSON objects into a uniform data structure\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n */\n\n \"use strict\";\nvar module = datarestructorInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction datarestructorInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * datarestructor namespace and module declaration.\n * It contains all functions to convert an object (e.g. parsed JSON) into uniform enumerated list of described field entries.\n * \n * <b>Transformation steps:</b>\n * - JSON\n * - flatten\n * - mark and identify\n * - add array fields\n * - deduplicate \n * - group\n * - flatten again\n * @module datarestructor\n */\nvar datarestructor = module.exports={}; // Export module for npm...\ndatarestructor.internalCreateIfNotExists = datarestructorInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\nvar template_resolver = template_resolver || require(\"../../src/js/templateResolver\"); // supports vanilla js & npm\nvar described_field = described_field || require(\"../../src/js/describedfield\"); // supports vanilla js & npm\n\n/**\n * Takes the full qualified original property name and extracts a simple name out of it.\n * \n * @callback module:datarestructor.propertyNameFunction\n * @param {string} propertyName full qualified, point separated property name \n * @return {String} extracted, simple name\n */\n\n/**\n * Describes a selected part of the incoming data structure and defines, \n * how the data should be transformed.\n * \n * @typedef {Object} module:datarestructor.PropertyStructureDescription\n * @property {string} type - \"\"(default). Some examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n * @property {string} category - name of the category. Default = \"\". Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {boolean} propertyPatternTemplateMode - \"false\"(default): property name needs to be equal to the pattern. \"true\" allows variables like \"{{fieldName}}\" inside the pattern.\n * @property {string} propertyPattern - property name pattern (without array indices) to match\n * @property {string} indexStartsWith - \"\"(default) matches all ids. String that needs to match the beginning of the id. E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n * @property {module:datarestructor.propertyNameFunction} getDisplayNameForPropertyName - display name for the property. \"\"(default) last property name element with upper case first letter.\n * @property {module:datarestructor.propertyNameFunction} getFieldNameForPropertyName - field name for the property. \"\" (default) last property name element.\n * @property {string} groupName - name of the property, that contains grouped entries. Default=\"group\".\n * @property {string} groupPattern - Pattern that describes how to group entries. \"groupName\" defines the name of this group. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationPattern - Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationName - (default=groupName) Name of the group when it had been moved to the destination.\n * @property {string} deduplicationPattern - Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n */\n\ndatarestructor.PropertyStructureDescriptionBuilder = (function () {\n  \"use strict\";\n\n  /**\n   * Builder for a {@link PropertyStructureDescription}.\n   * @constructs PropertyStructureDescriptionBuilder\n   * @alias module:datarestructor.PropertyStructureDescriptionBuilder\n   */\n  function PropertyStructureDescription() {\n    /**\n     * @type {module:datarestructor.PropertyStructureDescription}\n     */\n    this.description = {\n      type: \"\",\n      category: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      propertyPatternTemplateMode: false,\n      propertyPattern: \"\",\n      indexStartsWith: \"\",\n      groupName: \"group\",\n      groupPattern: \"\",\n      groupDestinationPattern: \"\",\n      groupDestinationName: null,\n      deduplicationPattern: \"\",\n      getDisplayNameForPropertyName: null,\n      getFieldNameForPropertyName: null,\n      matchesPropertyName: null\n    };\n    /**\n     * Sets the type.\n     * \n     * Contains the type of the entry, for example: \n     * - \"summary\" for e.g. a list overview. \n     * - \"detail\" e.g. when a summary is selected. \n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example type(\"summary\")\n     */\n    this.type = function (value) {\n      this.description.type = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the category.\n     * \n     * Contains a short domain nam, for example: \n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example category(\"Product\")\n     */\n    this.category = function (value) {\n      this.description.category = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     * \n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example abbreviation(\"P\")\n     */\n    this.abbreviation = function (value) {\n      this.description.abbreviation = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example image(\"img/product.png\")\n     */\n    this.image = function (value) {\n      this.description.image = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets \"equal mode\" for the property pattern.\n     * \n     * \"propertyPattern\" need to match exactly if this mode is activated.\n     *  It clears propertyPatternTemplateMode which means \"equal\" mode.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.propertyPatternEqualMode = function () {\n      this.description.propertyPatternTemplateMode = false;\n      return this;\n    };\n    /**\n     * Sets \"template mode\" for the property pattern.\n     * \n     * \"propertyPattern\" can contain variables like {{fieldName}} and\n     * doesn't need to match the property name exactly. If the \"propertyPattern\"\n     * is shorter than the property name, it also matches when the property name\n     * starts with the \"propertyPattern\".\n     * \n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.propertyPatternTemplateMode = function () {\n      this.description.propertyPatternTemplateMode = true;\n      return this;\n    };\n    /**\n     * Sets the property name pattern. \n     * \n     * Contains single property names with sub types separated by \".\" without array indices.\n     * May contain variables in double curly brackets.\n     * \n     * Example: \n     * - responses.hits.hits._source.{{fieldName}}\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n     */\n    this.propertyPattern = function (value) {\n      this.description.propertyPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional beginning of the id that needs to match.\n     * Matches all indices if set to \"\" (or not called).\n     * \n     * For example:\n     * - \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example indexStartsWith(\"1.\")\n     */\n    this.indexStartsWith = function (value) {\n      this.description.indexStartsWith = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Overrides the display name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name starting with an upper case character.\n     *  \n     * For example:\n     * - \"Product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example displayPropertyName(\"Product\")\n     */\n    this.displayPropertyName = function (value) {\n      this.description.getDisplayNameForPropertyName = createNameExtractFunction(value, this.description);\n      if (isSpecifiedString(value)) {\n        return this;\n      }\n      this.description.getDisplayNameForPropertyName = removeArrayValuePropertyPostfixFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      this.description.getDisplayNameForPropertyName = upperCaseFirstLetterForFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      return this;\n    };\n    /**\n     * Overrides the (technical) field name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name.\n     *  \n     * For example:\n     * - \"product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example fieldName(\"product\")\n     */\n    this.fieldName = function (value) {\n      this.description.getFieldNameForPropertyName = createNameExtractFunction(value, this.description);\n      return this;\n    };\n    /**\n     * Sets the name of the property, that contains grouped entries. \n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupName(\"details\")\n     */\n    this.groupName = function (value) {\n      this.description.groupName = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes how to group entries. \n     * \n     * \"groupName\" defines the name of this group.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupPattern(\"{{type}}-{{category}}\")\n     */\n    this.groupPattern = function (value) {\n      this.description.groupPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes where the group should be moved to. \n     * \n     * Default=\"\"=Group will not be moved.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"main-{{category}}\")\n     */\n    this.groupDestinationPattern = function (value) {\n      this.description.groupDestinationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the name of the group when it had been moved to the destination.\n     * \n     * The default value is the groupName, which will be used when the value is not valid (null or empty)\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"options\")\n     */\n    this.groupDestinationName = function (value) {\n      this.description.groupDestinationName = withDefault(value, this.description.groupName);\n      return this;\n    };\n    /**\n     * Sets the pattern to be used to remove duplicate entries. \n     * \n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n     */\n    this.deduplicationPattern = function (value) {\n      this.description.deduplicationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Finalizes the settings and builds the  PropertyStructureDescription.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.build = function () {\n      this.description.matchesPropertyName = createFunctionMatchesPropertyName(this.description);\n      if (this.description.getDisplayNameForPropertyName == null) {\n        this.displayPropertyName(\"\");\n      }\n      if (this.description.getFieldNameForPropertyName == null) {\n        this.fieldName(\"\");\n      }\n      if (this.description.groupDestinationName == null) {\n        this.groupDestinationName(\"\");\n      }\n      return this.description;\n    };\n  }\n\n  function createNameExtractFunction(value, description) {\n    if (isSpecifiedString(value)) {\n      return function () {\n        return value;\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      var patternToMatch = description.propertyPattern; // closure (closed over) parameter\n      return extractNameUsingTemplatePattern(patternToMatch);\n    }\n    return extractNameUsingRightMostPropertyNameElement();\n  }\n\n  function createFunctionMatchesPropertyName(description) {\n    var propertyPatternToMatch = description.propertyPattern; // closure (closed over) parameter\n    if (!isSpecifiedString(propertyPatternToMatch)) {\n      return function () {\n        return false; // Without a propertyPattern, no property will match (deactivated mark/identify).\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      return function (propertyNameWithoutArrayIndices) {\n        return templateModePatternRegexForPattern(propertyPatternToMatch).exec(propertyNameWithoutArrayIndices) != null;\n      };\n    }\n    return function (propertyNameWithoutArrayIndices) {\n      return propertyNameWithoutArrayIndices === propertyPatternToMatch;\n    };\n  }\n\n  function rightMostPropertyNameElement(propertyName) {\n    var regularExpression = new RegExp(\"(\\\\w+)$\", \"gi\");\n    var match = propertyName.match(regularExpression);\n    if (match != null) {\n      return match[0];\n    }\n    return propertyName;\n  }\n\n  function upperCaseFirstLetter(value) {\n    if (value.length > 1) {\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    }\n    return value;\n  }\n\n  function upperCaseFirstLetterForFunction(nameExtractFunction) {\n    return function (propertyName) {\n      return upperCaseFirstLetter(nameExtractFunction(propertyName));\n    };\n  }\n\n  function removeArrayValuePropertyPostfixFunction(nameExtractFunction) {\n    return function (propertyName) {\n      var name = nameExtractFunction(propertyName);\n      name = name != null ? name : \"\";\n      return name.replace(\"_comma_separated_values\", \"\");\n    };\n  }\n\n  function extractNameUsingTemplatePattern(propertyPattern) {\n    return function (propertyName) {\n      var regex = templateModePatternRegexForPatternAndVariable(propertyPattern, \"{{fieldName}}\");\n      var match = regex.exec(propertyName);\n      if (match && match[1] != \"\") {\n        return match[1];\n      }\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function extractNameUsingRightMostPropertyNameElement() {\n    return function (propertyName) {\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function templateModePatternRegexForPattern(propertyPatternToUse) {\n    var placeholderInDoubleCurlyBracketsRegEx = new RegExp(\"\\\\\\\\\\\\{\\\\\\\\\\\\{[-\\\\w]+\\\\\\\\\\\\}\\\\\\\\\\\\}\", \"gi\");\n    return templateModePatternRegexForPatternAndVariable(propertyPatternToUse, placeholderInDoubleCurlyBracketsRegEx);\n  }\n\n  function templateModePatternRegexForPatternAndVariable(propertyPatternToUse, variablePattern) {\n    var pattern = escapeCharsForRegEx(propertyPatternToUse);\n    if (typeof variablePattern === \"string\") {\n      variablePattern = escapeCharsForRegEx(variablePattern);\n    }\n    pattern = pattern.replace(variablePattern, \"([-\\\\w]+)\");\n    pattern = \"^\" + pattern;\n    return new RegExp(pattern, \"i\");\n  }\n\n  function escapeCharsForRegEx(characters) {\n    var nonWordCharactersRegEx = new RegExp(\"([^-\\\\w])\", \"gi\");\n    return characters.replace(nonWordCharactersRegEx, \"\\\\$1\");\n  }\n\n  function withDefault(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value != null && value != \"\";\n  }\n\n  return PropertyStructureDescription;\n})();\n\n/**\n * Adds a group item/entry to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntryFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n */\n\n/**\n * Adds some group items/entries to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntriesFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry[]} describedEntry entries that should be added to the group\n */\n\n/**\n * @typedef {Object} module:datarestructor.DescribedEntry\n * @property {string} category - category of the result from the PropertyStructureDescription using a short name or e.g. a symbol character\n * @property {string} type - type of the result from PropertyStructureDescription\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the split index. Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with the two elements: [2,4]\n * @property {string} displayName - display name extracted from the point separated hierarchical property name, e.g. \"Name\"\n * @property {string} fieldName - field name extracted from the point separated hierarchical property name, e.g. \"name\"\n * @property {string} value - content of the field\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {module:datarestructor.addGroupEntryFunction} addGroupEntry - function, that adds an entry to the given group. If the group does not exist, it will be created.\n * @property {module:datarestructor.addGroupEntriesFunction} addGroupEntries - function, that adds entries to the given group. If the group does not exist, it will be created.\n * @property {boolean} _isMatchingIndex - true, when _identifier.index matches the described \"indexStartsWith\"\n * @property {Object} _identifier - internal structure for identifier. Avoid using it outside since it may change.\n * @property {string} _identifier.index - array indices in hierarchical order separated by points, e.g. \"0.0\"\n * @property {string} _identifier.value - the (single) value of the \"flattened\" property, e.g. \"Smith\"\n * @property {string} _identifier.propertyNameWithArrayIndices - the \"original\" flattened property name in hierarchical order separated by points, e.g. \"responses[0].hits.hits[0]._source.name\"\n * @property {string} _identifier.propertyNameWithoutArrayIndices - same as propertyNamesWithArrayIndices but without array indices, e.g. \"responses.hits.hits._source.name\"\n * @property {string} _identifier.groupId - Contains the resolved groupPattern from the PropertyStructureDescription. Entries with the same id will be grouped into the \"groupName\" of the PropertyStructureDescription.\n * @property {string} _identifier.groupDestinationId - Contains the resolved groupDestinationPattern from the PropertyStructureDescription. Entries with this id will be moved to the given destination group.\n * @property {string} _identifier.deduplicationId - Contains the resolved deduplicationPattern from the PropertyStructureDescription. Entries with the same id will be considered to be a duplicate and hence removed.\n * @property {Object} _description - PropertyStructureDescription for internal use. Avoid using it outside since it may change.\n */\n\n/**\n * Returns a field value of the given {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.stringFieldOfDescribedEntryFunction\n * @param {module:datarestructor.DescribedEntry} entry described entry that contains the field that should be returned\n * @returns {String} field value \n */\n\ndatarestructor.DescribedEntryCreator = (function () {\n  \"use strict\";\n\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Creates a {@link module:datarestructor.DescribedEntry}.\n   * @constructs DescribedEntryCreator\n   * @alias module:datarestructor.DescribedEntryCreator\n   */\n  function DescribedEntry(entry, description) {\n    var indices = indicesOf(entry.name);\n    var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n    var templateResolver = new template_resolver.Resolver(this);\n    this.category = description.category;\n    this.type = description.type;\n    this.abbreviation = description.abbreviation;\n    this.image = description.image;\n    /**\n     * Array of numbers containing the split index.\n     * Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with two elements: [2,4]\n     * This is the public version of the internal variable _identifier.index, which contains in contrast all index elements in one point separated string (e.g. \"2.4\").\n     * @type {number[]}\n     */\n    this.index = indices.numberArray;\n    this.displayName = description.getDisplayNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.fieldName = description.getFieldNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.value = entry.value;\n    this.groupNames = [];\n    this._isMatchingIndex = indices.pointDelimited.indexOf(description.indexStartsWith) == 0;\n    this._description = description;\n\n    this._identifier = {\n      index: indices.pointDelimited,\n      propertyNameWithArrayIndices: entry.name,\n      propertyNameWithoutArrayIndices: propertyNameWithoutArrayIndices,\n      groupId: \"\",\n      groupDestinationId: \"\",\n      deduplicationId: \"\"\n    };\n    this._identifier.groupId = templateResolver.replaceResolvableFields(\n      description.groupPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.groupDestinationId = templateResolver.replaceResolvableFields(\n      description.groupDestinationPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.deduplicationId = templateResolver.replaceResolvableFields(\n      description.deduplicationPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName name of the group that should be added\n     * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n     */\n    this.addGroupEntry = function(groupName, describedEntry) {\n      this.addGroupEntries(groupName, [describedEntry]);\n    };\n\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName\n     * @param {module:datarestructor.DescribedEntry[]} describedEntries\n     */\n    this.addGroupEntries = function(groupName, describedEntries) {\n      if (!this[groupName]) {\n        this.groupNames.push(groupName);\n        this[groupName] = [];\n      }\n      var index;\n      var describedEntry;\n      for (index = 0; index < describedEntries.length; index += 1) {\n        describedEntry = describedEntries[index];\n        this[groupName].push(describedEntry);\n      }\n    };\n  }\n  /**\n   * @typedef {Object} module:datarestructor.ExtractedIndices\n   * @property {string} pointDelimited - bracket indices separated by points\n   * @property {number[]} numberArray as array of numbers\n   */\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {String} fullPropertyName\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n  function indicesOf(fullPropertyName) {\n    var arrayBracketsRegEx = new RegExp(\"\\\\[(\\\\d+)\\\\]\", \"gi\");\n    return indicesOfWithRegex(fullPropertyName, arrayBracketsRegEx);\n  }\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {string} fullPropertyName\n   * @param {RegExp} regexWithOneNumberGroup\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n  function indicesOfWithRegex(fullPropertyName, regexWithOneNumberGroup) {\n    var pointDelimited = \"\";\n    var numberArray = [];\n    var match;\n    do {\n      match = regexWithOneNumberGroup.exec(fullPropertyName);\n      if (match) {\n        if (pointDelimited.length > 0) {\n          pointDelimited += \".\";\n        }\n        pointDelimited += match[1];\n        numberArray.push(parseInt(match[1]));\n      }\n    } while (match);\n    return { pointDelimited: pointDelimited, numberArray: numberArray };\n  }\n\n  return DescribedEntry;\n})();\n\n  /**\n   * @typedef {Object} module:datarestructor.TransformConfig\n   * @property {boolean} debugMode enables/disables detailed logging\n   * @property {number} [maxRecursionDepth=8] Maximum recursion depth\n   * @property {number} [removeDuplicationAboveRecursionDepth=1]  Duplications will be removed above the given recursion depth value and remain unchanged below it.\n   */\n\n\ndatarestructor.Transform = (function () {\n  \"use strict\";\n\n  /**\n   * Main class for the data transformation.\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions\n   * @constructs Transform\n   * @alias module:datarestructor.Transform\n   */\n  function Transform(descriptions) {\n    /**\n     * Descriptions of the input data that define the behaviour of the transformation.\n     * @type {module:datarestructor.DescribedEntry[]}\n     */\n    this.descriptions = descriptions;\n    /**\n     * Configuration for the transformation.\n     * @protected\n     * @type {module:datarestructor.TransformConfig}\n     */\n    this.config = {\n      /**\n       * Debug mode switch, that enables/disables detailed logging.\n       * @protected\n       * @type {boolean}\n       */\n      debugMode: false,\n      /**\n       * Maximum recursion depth. Defaults to 8.\n       * @protected\n       * @type {number}\n       */\n      maxRecursionDepth: 8,\n      /**\n       * Duplications will be removed above the given recursion depth and remain below it.\n       * Defaults to 1.\n       *\n       * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n       * data structures are possible by nature and will lead to duplications. Some of them\n       * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n       * To restrict duplications and improve performance it is beneficial to define a\n       * recursion depth, above which further duplication won't be used and should be removed/avoided.\n       *\n       * @protected\n       * @type {number}\n       */\n      removeDuplicationAboveRecursionDepth: 1\n    };\n    /**\n     * Enables debug mode. Logs additional information.\n     * @returns {module:datarestructor.Transform}\n     */\n    this.enableDebugMode = function () {\n      this.config.debugMode = true;\n      return this;\n    };\n\n    /**\n     * Sets the maximum recursion depth. Defaults to 8 if not set.\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */\n    this.setMaxRecursionDepth = function (value) {\n      if (typeof value !== \"number\" || value < 0) {\n        throw \"Invalid max recursion depth value: \" + value;\n      }\n      this.config.maxRecursionDepth = value;\n      return this;\n    };\n    /**\n     * Sets the recursion depth above which duplication will be removed. Duplications below it remain unchanged.\n     * Defaults to 1.\n     *\n     * Since fields can contain groups of fields that can contain groups of fields..., cyclic\n     * data structures are possible by nature and will lead to duplications. Some of them\n     * might be intended e.g. to take one (sub-)field with all (duplicated) groups.\n     * To restrict duplications and improve performance it is beneficial to define a\n     * recursion depth, above which further duplication won't be used and should be removed/avoided.\n     *\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */\n    this.setRemoveDuplicationAboveRecursionDepth = function (value) {\n      if (typeof value !== \"number\" || value < 0) {\n        throw \"Invalid remove duplications above recursion depth value: \" + value;\n      }\n      this.config.removeDuplicationAboveRecursionDepth = value;\n      return this;\n    };\n    /**\n     * \"Assembly line\", that takes the (pared JSON) data and processes it using all given descriptions in their given order.\n     * @param {object} data - parsed JSON data or any other data object\n     * @returns {module:datarestructor.DescribedEntry[]}\n     * @example\n     * var allDescriptions = [];\n     * allDescriptions.push(summariesDescription());\n     * allDescriptions.push(detailsDescription());\n     * var result = new datarestructor.Transform(allDescriptions).processJson(jsonData);\n     */\n    this.processJson = function (data) {\n      return processJsonUsingDescriptions(data, this.descriptions, this.config);\n    };\n  }\n\n  /**\n   * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n   * @param {object} jsonData parsed JSON data or any other data object\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function processJsonUsingDescriptions(jsonData, descriptions, config) {\n    // \"Flatten\" the hierarchical input json to an array of property names (point separated \"folders\") and values.\n    var processedData = internal_object_tools.flattenToArray(jsonData);\n    // Fill in properties ending with the name \"_comma_separated_values\" for array values to make it easier to display them.\n    processedData = fillInArrayValues(processedData);\n\n    if (config.debugMode) {\n      console.log(\"flattened data with array values:\");\n      console.log(processedData);\n    }\n\n    // Mark, identify and harmonize the flattened data by applying one description after another in their given order.\n    var describedData = [];\n    var descriptionIndex, description, dataWithDescription;\n    for (descriptionIndex = 0; descriptionIndex < descriptions.length; descriptionIndex += 1) {\n      description = descriptions[descriptionIndex];\n      // Filter all entries that match the current description and enrich them with it\n      dataWithDescription = extractEntriesByDescription(processedData, description);\n      // Remove duplicate entries where a deduplicationPattern is described\n      describedData = deduplicateFlattenedData(describedData, dataWithDescription);\n    }\n    processedData = describedData;\n\n    if (config.debugMode) {\n      console.log(\"describedData data:\");\n      console.log(processedData);\n    }\n\n    // Group entries where a groupPattern is described\n    processedData = groupFlattenedData(processedData);\n\n    if (config.debugMode) {\n      console.log(\"grouped describedData data:\");\n      console.log(processedData);\n    }\n\n    // Move group entries where a groupDestinationPattern is described\n    processedData = applyGroupDestinationPattern(processedData);\n\n    if (config.debugMode) {\n      console.log(\"moved grouped describedData data:\");\n      console.log(processedData);\n    }\n\n    // Turns the grouped object back into an array of DescribedEntry-Objects\n    processedData = propertiesAsArray(processedData);\n\n    // Converts the internal described entries  into described fields\n    processedData = toDescribedFields(processedData, config);\n\n    if (config.debugMode) {\n      console.log(\"transformed result:\");\n      console.log(processedData);\n    }\n\n    return processedData;\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries that occur later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * The id is extracted from every element using the given function.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function mergeFlattenedData(entries, entriesToMerge, idOfElementFunction) {\n    var entriesToMergeById = asIdBasedObject(entriesToMerge, idOfElementFunction);\n    var merged = [];\n    var index, entry, id;\n    for (index = 0; index < entries.length; index += 1) {\n      entry = entries[index];\n      id = idOfElementFunction(entry);\n      if (id == null || id === \"\" || entriesToMergeById[id] == null) {\n        merged.push(entry);\n      }\n    }\n    for (index = 0; index < entriesToMerge.length; index += 1) {\n      entry = entriesToMerge[index];\n      merged.push(entry);\n    }\n    return merged;\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries occurring later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * \"entriesToMerge\" will be returned directly, if \"entries\" is null or empty.\n   *\n   * The id is extracted from every element using their deduplication pattern (if available).\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @see mergeFlattenedData\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function deduplicateFlattenedData(entries, entriesToMerge) {\n    if (entries == null || entries.length == 0) {\n      return entriesToMerge;\n    }\n    var idOfElementFunction = function (entry) {\n      return entry._identifier.deduplicationId;\n    };\n    return mergeFlattenedData(entries, entriesToMerge, idOfElementFunction);\n  }\n\n  /**\n   * Converts the given elements to an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1.\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function asIdBasedObject(elements, idOfElementFunction) {\n    var idIndexedObject = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      idIndexedObject[idOfElementFunction(element)] = element;\n    }\n    return idIndexedObject;\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id (determined by the entry's groupPattern).\n   * For example, [{id: A, value: 1}] becomes result['A'] = 1.\n   *\n   * Furthermore, this function creates a group property (determined by the entry's groupName)\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function groupFlattenedData(flattenedData) {\n    return groupById(\n      flattenedData,\n      function (entry) {\n        return entry._identifier.groupId;\n      },\n      function (entry) {\n        return entry._description.groupName;\n      }\n    );\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1. Furthermore, this function creates a group property (with the name )\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupNameOfElementFunction function, that returns the name of the group property that will be created inside the \"main\" element.\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupIdOfElementFunction returns the group id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function groupById(elements, groupIdOfElementFunction, groupNameOfElementFunction) {\n    var groupedResult = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      var groupId = groupIdOfElementFunction(element);\n      if (groupId === \"\") {\n        continue;\n      }\n      var groupName = groupNameOfElementFunction(element);\n      if (groupName == null || groupName === \"\") {\n        continue;\n      }\n      if (!groupedResult[groupId]) {\n        groupedResult[groupId] = element;\n      }\n      groupedResult[groupId].addGroupEntry(groupName, element);\n    }\n    return groupedResult;\n  }\n\n  /**\n   * Extracts entries out of \"flattened\" JSON data and provides an array of objects.\n   * @param {Object[]} flattenedData - flattened json from search query result\n   * @param {string} flattenedData[].name - name of the property in hierarchical order separated by points\n   * @param {string} flattenedData[].value - value of the property as string\n   * @param {module:datarestructor.PropertyStructureDescription} - description of structure of the entries that should be extracted\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function extractEntriesByDescription(flattenedData, description) {\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    var filtered = [];\n\n    flattenedData.filter(function (entry) {\n      var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n      if (description.matchesPropertyName(propertyNameWithoutArrayIndices)) {\n        var describedEntry = new datarestructor.DescribedEntryCreator(entry, description);\n        if (describedEntry._isMatchingIndex) {\n          filtered.push(describedEntry);\n        }\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * Takes already grouped {@link module:datarestructor.DescribedEntry} objects and\n   * uses their \"_identifier.groupDestinationId\" (if exists)\n   * to move groups to the given destination.\n   *\n   * This is useful, if separately described groups like \"summary\" and \"detail\" should be put together,\n   * so that every summery contains a group with the regarding details.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} groupedObject - already grouped entries\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function applyGroupDestinationPattern(groupedObject) {\n    var keys = Object.keys(groupedObject);\n    var keysToDelete = [];\n    for (var index = 0; index < keys.length; index++) {\n      var key = keys[index];\n      var entry = groupedObject[key];\n      if (entry._description.groupDestinationPattern != \"\") {\n        var destinationKey = entry._identifier.groupDestinationId;\n        if (groupedObject[destinationKey] != null) {\n          var newGroup = entry[entry._description.groupName];\n          groupedObject[destinationKey].addGroupEntries(entry._description.groupDestinationName, newGroup);\n          keysToDelete.push(key);\n        }\n      }\n    }\n    // delete all moved entries that had been collected by their key\n    for (index = 0; index < keysToDelete.length; index += 1) {\n      var keyToDelete = keysToDelete[index];\n      delete groupedObject[keyToDelete];\n    }\n    return groupedObject;\n  }\n\n  /**\n   * Fills in extra \"_comma_separated_values\" properties into the flattened data\n   * for properties that end with an array. E.g. response.hits.hits.tags[0]=\"active\" and response.hits.hits.tags[0]=\"ready\"\n   * will lead to the extra element \"response.hits.hits.tags_comma_separated_values=\"active, ready\".\n   *\n   * @return flattened data with filled in \"_comma_separated_values\" properties\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function fillInArrayValues(flattenedData) {\n    var trailingArrayIndexRegEx = new RegExp(\"\\\\[\\\\d+\\\\]$\", \"gi\");\n    var result = [];\n    var lastArrayProperty = \"\";\n    var lastArrayPropertyValue = \"\";\n\n    flattenedData.filter(function (entry) {\n      if (!entry.name.match(trailingArrayIndexRegEx)) {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        result.push(entry);\n        return;\n      }\n      var propertyNameWithoutTrailingArrayIndex = entry.name.replace(trailingArrayIndexRegEx, \"\");\n      if (lastArrayProperty === propertyNameWithoutTrailingArrayIndex) {\n        lastArrayPropertyValue += \", \" + entry.value;\n      } else {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        lastArrayProperty = propertyNameWithoutTrailingArrayIndex;\n        lastArrayPropertyValue = entry.value;\n      }\n      result.push(entry);\n    });\n    return result;\n  }\n\n  function propertiesAsArray(groupedData) {\n    var result = [];\n    var propertyNames = Object.keys(groupedData);\n    for (var propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex++) {\n      var propertyName = propertyNames[propertyIndex];\n      var propertyValue = groupedData[propertyName];\n      result.push(propertyValue);\n    }\n    return result;\n  }\n\n  /**\n   * Converts described entries (internal data structure) to described fields (external data structure).\n   * Since the structure of a described field is hierarchical, every field needs to be converted\n   * in a recursive manner. The maximum recursion depth is taken as the second parameter.\n   * @param {module:datarestructor.DescribedEntry[]} describedEntries\n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   * @returns {module:described_field.DescribedDataField[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function toDescribedFields(describedEntries, config) {\n    var result = [];\n    var index;\n    var describedEntity;\n    for (index = 0; index < describedEntries.length; index += 1) {\n      describedEntity = describedEntries[index];\n      result.push(toDescribedField(describedEntity, {recursionDepth:0, config: config, groupToSkip:\"\"}));\n    }\n    return result;\n  }\n\n  /**\n   * Describes the context type for the recursive DescribedDataField conversion,\n   * that contains everything that needs to be accessible throughout recursion regardless of the\n   * recursion depth.\n   *\n   * @typedef {Object} module:datarestructor.DescribedFieldRecursionContext\n   * @param {number} recursionDepth current recursion depth\n   * @param {String} groupToSkip name of a group to skip or \"\" when no group should be skipped. \n   * @param {module:datarestructor.TransformConfig} config configuration for the data transformation\n   */\n\n  /**\n   * Converts a internal described entry to a newly created public described field.\n   * Since the structure of a described field is hierarchical, this function is called recursively.\n   * Because the internal described entries may very likely contain cyclic references, the depth of recursion\n   * needs to be limited. Therefore, the current recursion depth is taken as second parameter\n   * and the maximum recursion depth is taken as third parameter.\n   * @param {module:datarestructor.DescribedEntry} entry the internal entry that will be converted\n   * @param {module:datarestructor.DescribedFieldRecursionContext} recursionContext context contains everything that needs to be accessible throughout the recursion.\n   * @returns {module:described_field.DescribedDataField}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function toDescribedField(entry, recursionContext) {\n    var field = new described_field.DescribedDataFieldBuilder()\n      .category(entry.category)\n      .type(entry.type)\n      .abbreviation(entry.abbreviation)\n      .image(entry.image)\n      .index(entry.index)\n      .displayName(entry.displayName)\n      .fieldName(entry.fieldName)\n      .value(entry.value)\n      .build();\n    if (recursionContext.recursionDepth > recursionContext.config.maxRecursionDepth) {\n      return field;\n    }\n    var nextRecursionContext = null;\n    var duplicateGroupNameToSkip = \"\";\n    var fieldGroups = new described_field.DescribedDataFieldGroup(field);\n    forEachGroupEntry(entry, function (groupName, groupEntry, allGroupEntries) {\n      if (recursionContext.groupToSkip === groupName) {\n        if (recursionContext.config.debugMode) {\n          console.log(\"Removed duplicate group \" + groupName + \" at recursion depth \" + recursionContext.recursionDepth);\n        }\n        return;\n      }\n      duplicateGroupNameToSkip = \"\";\n      if (recursionContext.recursionDepth >= recursionContext.config.removeDuplicationAboveRecursionDepth) {\n        duplicateGroupNameToSkip = arraysEqual(groupEntry[groupName], allGroupEntries, describedFieldEqual)? groupName : \"\";\n      }\n      nextRecursionContext = {recursionDepth: recursionContext.recursionDepth + 1, config: recursionContext.config, groupToSkip: duplicateGroupNameToSkip};\n      fieldGroups.addGroupEntry(groupName, toDescribedField(groupEntry, nextRecursionContext));\n    });\n    return field;\n  }\n\n  function describedFieldEqual(a, b) {\n    return (\n      defaultEmpty(a.category) === defaultEmpty(b.category) &&\n      defaultEmpty(a.type) === defaultEmpty(b.type) &&\n      a.fieldName === b.fieldName &&\n      a.value === b.value\n    );\n  }\n\n  function defaultEmpty(value) {\n    return defaultValue(value, \"\");\n  }\n\n  function defaultValue(value, valueAsDefault) {\n    if (typeof value === \"undefined\" || !value) {\n      return valueAsDefault;\n    }\n    return value;\n  }\n\n  // Reference: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript/16430730\n  // Added \"elementEqualFunction\" to implement equal object detection.\n  // Arrays are assumed to be sorted. Differently ordered entries are treated as not equal.\n  function arraysEqual(a, b, elementEqualFunction) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n      if (!elementEqualFunction(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Takes the full qualified original property name and extracts a simple name out of it.\n   *\n   * @callback module:datarestructor.onEntryFoundFunction\n   * @param {string} groupName name of the group where the entry had been found.\n   * @param {module:datarestructor.DescribedEntry} foundEntry the found entry itself.\n   * @param {module:datarestructor.DescribedEntry[]} allEntries the array of all entries where the found entry is an element of.\n   */\n\n  /**\n   * Traverses through all groups and their entries and calls the given function on every found entry\n   * with the group name and the entry itself as parameters.\n   * @param {module:datarestructor.DescribedEntry} rootEntry\n   * @param {module:datarestructor.onEntryFoundFunction} onFoundEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function forEachGroupEntry(rootEntry, onFoundEntry) {\n    var groupIndex, entryIndex;\n    var groupName, entry;\n    for (groupIndex = 0; groupIndex < rootEntry.groupNames.length; groupIndex += 1) {\n      groupName = rootEntry.groupNames[groupIndex];\n      for (entryIndex = 0; entryIndex < rootEntry[groupName].length; entryIndex += 1) {\n        entry = rootEntry[groupName][entryIndex];\n        onFoundEntry(groupName, entry, rootEntry[groupName]);\n      }\n    }\n  }\n  return Transform;\n}());\n\n/**\n * Main fassade for the data restructor as static function(s).\n * \n * @example \n * var allDescriptions = [];\n * allDescriptions.push(summariesDescription());\n * allDescriptions.push(detailsDescription());\n * var result = datarestructor.Restructor.processJsonUsingDescriptions(jsonData, allDescriptions);\n * @namespace module:datarestructor.Restructor\n */\ndatarestructor.Restructor = {};\n/**\n * Static fassade function for the \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n * @param {object} jsonData - parsed JSON data or any other data object\n * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n * @returns {module:datarestructor.DescribedEntry[]}\n * @memberof module:datarestructor.Restructor\n * @deprecated since v3.1.0, please use \"new datarestructor.Transform(descriptions).processJson(jsonData)\".\n */\ndatarestructor.Restructor.processJsonUsingDescriptions = function(jsonData, descriptions, debugMode) {\n  var restructor = new datarestructor.Transform(descriptions);\n  if (debugMode) {\n    restructor.enableDebugMode();\n  }\n  return restructor.processJson(jsonData);\n};","\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\nvar internal_object_tools = module.exports={}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n    if (Object(cur) !== cur) {\n      result.push({ name: prop, value: cur });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n      if (l === 0) {\n        result[prop] = [];\n        result.push({ name: prop, value: \"\" });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n      if (isEmpty && prop) {\n        result.push({ name: prop, value: \"\" });\n      }\n    }\n  }\n  recurse(data, \"\", 0);\n  return result;\n};\n","/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = templateResolverInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction templateResolverInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */\nvar template_resolver = (module.exports = {}); // Export module for npm...\ntemplate_resolver.internalCreateIfNotExists = templateResolverInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\ntemplate_resolver.Resolver = (function () {\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Resolver. Is used inside this repository. It could also be used outside.\n   * @param {*} sourceDataObject The properties of this object will be used to replace the placeholders in the template.\n   * @constructs Resolver\n   * @alias module:template_resolver.Resolver\n   */\n  function Resolver(sourceDataObject) {\n    /**\n     * The properties of this source data object will be used to replace the placeholders in the template.\n     */\n    this.sourceDataObject = sourceDataObject;\n    /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */\n    this.resolveTemplate = function (template) {\n      return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n    };\n    /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     * @public\n     */\n    this.resolvableFieldsOfAll = function () {\n      var map = {};\n      var ignoreInternalFields = function (propertyName) {\n        return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n      };\n      var index;\n      for (index = 0; index < arguments.length; index += 1) {\n        addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n      }\n      return map;\n    };\n    /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */\n    this.replaceResolvableFields = function (stringContainingVariables, resolvableFields) {\n      var replaced = stringContainingVariables;\n      var propertyNames = Object.keys(resolvableFields);\n      var propertyIndex = 0;\n      var propertyName = \"\";\n      var propertyValue = \"\";\n      for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n        propertyName = propertyNames[propertyIndex];\n        propertyValue = resolvableFields[propertyName];\n        replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n      }\n      return replaced;\n    };\n  }\n\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName);\n      // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n      // and a property named \"value\" inside the same sub object (containing its value).\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      // TODO could make \"fieldName\" and \"value\" configurable\n      if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n    var propertyGroup = \"\";\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return { group: propertyGroup, groupWithoutArrayIndices: propertyGroupWithoutArrayIndices, name: propertyName };\n  }\n\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n    return mapObject;\n  }\n\n  return Resolver;\n}());\n","/**\n * @file Describes a data field of the restructured data.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = describedFieldInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction describedFieldInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Describes a data field of the restructured data.\n * @module described_field\n */\nvar described_field = (module.exports = {}); // Export module for npm...\ndescribed_field.internalCreateIfNotExists = describedFieldInternalCreateIfNotExists;\n\n/**\n * Describes a field of the restructured data.\n * Dynamically added properties represent custom named groups containing DescribedDataField-Arrays.\n *\n * @typedef {Object} module:described_field.DescribedDataField\n * @property {string} [category=\"\"] - name of the category. Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [type=\"\"] - type of the data element. Examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as data filters.\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the splitted index. Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4]\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {string} displayName - display name of the field\n * @property {string} fieldName - field name\n * @property {{*}} value - content of the field\n * @property {module:described_field.DescribedDataField[]} [couldBeAnyCustomGroupName] any number of groups attached to the field each containing multiple fields\n */\n\ndescribed_field.DescribedDataFieldBuilder = (function () {\n  /**\n   * Builds a {@link module:described_field.DescribedDataField}.\n   * DescribedDataField is the main element of the restructured data and therefore considered \"public\".\n   * @constructs DescribedDataFieldBuilder\n   * @alias module:described_field.DescribedDataFieldBuilder\n   */\n  function DescribedDataFieldBuilder() {\n    /**\n     * @type {module:described_field.DescribedDataField}\n     */\n    this.describedField = {\n      category: \"\",\n      type: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      index: [],\n      groupNames: [],\n      displayName: \"\",\n      fieldName: \"\",\n      value: \"\"\n    };\n    /**\n     * Takes over all values of the template {@link module:described_field.DescribedDataField}.\n     * @function\n     * @param {module:described_field.DescribedDataField} template\n     * @returns {DescribedDataFieldBuilder}\n     * @example fromDescribedDataField(sourceField)\n     */\n    this.fromDescribedDataField = function (template) {\n      this.category(template.category);\n      this.type(template.type);\n      this.abbreviation(template.abbreviation);\n      this.image(template.image);\n      this.index(template.index);\n      this.groupNames(template.groupNames);\n      this.displayName(template.displayName);\n      this.fieldName(template.fieldName);\n      this.value(template.value);\n      return this;\n    };\n    /**\n     * Sets the category.\n     *\n     * Contains a short domain nam, for example:\n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example category(\"Product\")\n     */\n    this.category = function (value) {\n      this.describedField.category = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the type.\n     *\n     * Contains the type of the entry, for example:\n     * - \"summary\" for e.g. a list overview.\n     * - \"detail\" e.g. when a summary is selected.\n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example type(\"summary\")\n     */\n    this.type = function (value) {\n      this.describedField.type = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     *\n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example abbreviation(\"P\")\n     */\n    this.abbreviation = function (value) {\n      this.describedField.abbreviation = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example image(\"img/product.png\")\n     */\n    this.image = function (value) {\n      this.describedField.image = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the index as an array of numbers containing the splitted array indexes of the source field.\n     * Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4].\n     *\n     * @function\n     * @param {number[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example index([2,4])\n     */\n    this.index = function (value) {\n      this.describedField.index = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the group names as an array of strings containing the names of the dynamically added properties,\n     * that contain an array of {@link module:described_field.DescribedDataField}-Objects.\n     *\n     * @function\n     * @param {string[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example groupNames([\"summaries\",\"details\",\"options\"])\n     */\n    this.groupNames = function (value) {\n      this.describedField.groupNames = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the display name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example displayName(\"Color\")\n     */\n    this.displayName = function (value) {\n      this.describedField.displayName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the (technical) field name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example fieldName(\"color\")\n     */\n    this.fieldName = function (value) {\n      this.describedField.fieldName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the value/content of the field.\n     *\n     * @function\n     * @param {*} value\n     * @returns {DescribedDataFieldBuilder}\n     * @example value(\"darkblue\")\n     */\n    this.value = function (value) {\n      this.describedField.value = value;\n      return this;\n    };\n\n    /**\n     * Finalizes the settings and builds the {@link module:described_field.DescribedDataField}.\n     * @function\n     * @returns {module:described_field.DescribedDataField}\n     */\n    this.build = function () {\n      return this.describedField;\n    };\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value !== null && value !== \"\";\n  }\n\n  function withDefaultString(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function withDefaultArray(value, defaultValue) {\n    return value === undefined || value === null ? defaultValue : value;\n  }\n\n  return DescribedDataFieldBuilder;\n}());\n\n/**\n * Creates a new described data field with all properties of the original one except for dynamically added groups.\n * @param {module:described_field.DescribedDataField} describedDataField\n * @returns {module:described_field.DescribedDataField}\n * @memberof module:described_field\n */\ndescribed_field.copyWithoutGroups = function (describedDataField) {\n  return new described_field.DescribedDataFieldBuilder().fromDescribedDataField(describedDataField).groupNames([]).build();\n};\n\ndescribed_field.DescribedDataFieldGroup = (function () {\n  /**\n   * Adds groups to {@link module:described_field.DescribedDataField}s. These groups are dynamically added properties\n   * that contain an array of sub fields of the same type {@link module:described_field.DescribedDataField}s.\n   *\n   * @param {module:described_field.DescribedDataField} dataField\n   * @constructs DescribedDataFieldGroup\n   * @alias module:described_field.DescribedDataFieldGroup\n   * @example new described_field.DescribedDataFieldGroup(field).addGroupEntry(\"details\", detailField);\n   */\n  function DescribedDataFieldGroup(dataField) {\n    this.dataField = dataField;\n\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entry will be added\n     * @param {module:described_field.DescribedDataField} describedField sub field that is added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n    this.addGroupEntry = function (groupName, describedField) {\n      this.addGroupEntries(groupName, [describedField]);\n      return this;\n    };\n\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entries will be added\n     * @param {module:described_field.DescribedDataField[]} describedFields sub fields that are added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n    this.addGroupEntries = function (groupName, describedFields) {\n      if (!groupName || groupName.length === 0) {\n        return this;\n      }\n      if (!describedFields || describedFields.length === 0) {\n        return this;\n      }\n      if (this.dataField[groupName] === undefined) {\n        this.dataField.groupNames.push(groupName);\n        this.dataField[groupName] = [];\n      }\n      var index;\n      var describedField;\n      for (index = 0; index < describedFields.length; index += 1) {\n        describedField = describedFields[index];\n        this.dataField[groupName].push(describedField);\n      }\n      return this;\n    };\n  }\n\n  return DescribedDataFieldGroup;\n}());\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","removeArrayBracketsRegEx","$ebb82346238f20d7$var$module","$ebb82346238f20d7$var$datarestructorInternalCreateIfNotExists","objectToCheck","$ebb82346238f20d7$var$datarestructor","internalCreateIfNotExists","$ebb82346238f20d7$var$internal_object_tools","$ebb82346238f20d7$var$template_resolver","$ebb82346238f20d7$var$described_field","PropertyStructureDescriptionBuilder","createNameExtractFunction","value","description","propertyPattern","isSpecifiedString","propertyPatternTemplateMode","propertyName","match","regex","templateModePatternRegexForPatternAndVariable","exec","rightMostPropertyNameElement","regularExpression","RegExp","propertyPatternToUse","variablePattern","pattern","escapeCharsForRegEx","replace","characters","nonWordCharactersRegEx","withDefault","defaultValue","type","category","abbreviation","image","indexStartsWith","groupName","groupPattern","groupDestinationPattern","groupDestinationName","deduplicationPattern","getDisplayNameForPropertyName","getFieldNameForPropertyName","matchesPropertyName","propertyPatternEqualMode","displayPropertyName","nameExtractFunction","name","length","charAt","toUpperCase","slice","fieldName","build","propertyPatternToMatch","propertyNameWithoutArrayIndices","templateModePatternRegexForPattern","DescribedEntryCreator","entry","indices","indicesOfWithRegex","fullPropertyName","regexWithOneNumberGroup","pointDelimited","numberArray","push","parseInt","templateResolver","Resolver","index","displayName","groupNames","_isMatchingIndex","indexOf","_description","_identifier","propertyNameWithArrayIndices","groupId","groupDestinationId","deduplicationId","replaceResolvableFields","resolvableFieldsOfAll","addGroupEntry","describedEntry","addGroupEntries","describedEntries","Transform","describedFieldEqual","a","b","defaultEmpty","valueAsDefault","descriptions","config","debugMode","maxRecursionDepth","removeDuplicationAboveRecursionDepth","enableDebugMode","setMaxRecursionDepth","setRemoveDuplicationAboveRecursionDepth","processJson","data","processJsonUsingDescriptions","jsonData","flattenedData","trailingArrayIndexRegEx","result","lastArrayProperty","lastArrayPropertyValue","entries","entriesToMerge","descriptionIndex","processedData","flattenToArray","filter","propertyNameWithoutTrailingArrayIndex","console","log","describedData","extractEntriesByDescription","filtered","mergeFlattenedData","idOfElementFunction","entriesToMergeById","asIdBasedObject","elements","idIndexedObject","element","merged","groupById","groupIdOfElementFunction","groupNameOfElementFunction","groupedResult","applyGroupDestinationPattern","groupedObject","keys","Object","keysToDelete","key","destinationKey","newGroup","keyToDelete","toDescribedFields","toDescribedField","recursionContext","field","DescribedDataFieldBuilder","recursionDepth","nextRecursionContext","duplicateGroupNameToSkip","fieldGroups","DescribedDataFieldGroup","forEachGroupEntry","rootEntry","onFoundEntry","groupIndex","entryIndex","groupEntry","allGroupEntries","groupToSkip","arraysEqual","elementEqualFunction","i","propertiesAsArray","groupedData","propertyNames","propertyIndex","propertyValue","Restructor","restructor","$8e2fb4eb18d4597b$var$module","$8e2fb4eb18d4597b$var$internal_object_tools","recurse","cur","prop","depth","Array","isArray","l","p","isEmpty","$9cb0fe3475961b60$var$module","$9cb0fe3475961b60$var$templateResolverInternalCreateIfNotExists","$9cb0fe3475961b60$var$template_resolver","$9cb0fe3475961b60$var$internal_object_tools","sourceDataObject","resolveTemplate","template","addFieldsPerGroup","map","propertyInfo","getPropertyNameInfos","positionOfRightMostSeparator","lastIndexOf","substr","propertyGroup","propertyGroupWithoutArrayIndices","group","groupWithoutArrayIndices","ignoreInternalFields","arguments","addToFilteredMapObject","mapObject","filterMatchesFunction","stringContainingVariables","resolvableFields","replaced","$7d0608def849b52f$var$module","$7d0608def849b52f$var$describedFieldInternalCreateIfNotExists","$7d0608def849b52f$var$described_field","withDefaultString","describedField","fromDescribedDataField","copyWithoutGroups","describedDataField","dataField","describedFields","undefined"],"version":3,"file":"datarestructor.js.map","sourceRoot":"../"}