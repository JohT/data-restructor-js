{"mappings":"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","sources":["src/js/templateResolver.js","lib/js/flattenToArray.js"],"sourcesContent":["/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = templateResolverInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction templateResolverInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */\nvar template_resolver = (module.exports = {}); // Export module for npm...\ntemplate_resolver.internalCreateIfNotExists = templateResolverInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\ntemplate_resolver.Resolver = (function () {\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Resolver. Is used inside this repository. It could also be used outside.\n   * @param {*} sourceDataObject The properties of this object will be used to replace the placeholders in the template.\n   * @constructs Resolver\n   * @alias module:template_resolver.Resolver\n   */\n  function Resolver(sourceDataObject) {\n    /**\n     * The properties of this source data object will be used to replace the placeholders in the template.\n     */\n    this.sourceDataObject = sourceDataObject;\n    /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */\n    this.resolveTemplate = function (template) {\n      return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n    };\n    /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     * @public\n     */\n    this.resolvableFieldsOfAll = function () {\n      var map = {};\n      var ignoreInternalFields = function (propertyName) {\n        return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n      };\n      var index;\n      for (index = 0; index < arguments.length; index += 1) {\n        addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n      }\n      return map;\n    };\n    /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */\n    this.replaceResolvableFields = function (stringContainingVariables, resolvableFields) {\n      var replaced = stringContainingVariables;\n      var propertyNames = Object.keys(resolvableFields);\n      var propertyIndex = 0;\n      var propertyName = \"\";\n      var propertyValue = \"\";\n      for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n        propertyName = propertyNames[propertyIndex];\n        propertyValue = resolvableFields[propertyName];\n        replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n      }\n      return replaced;\n    };\n  }\n\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName);\n      // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n      // and a property named \"value\" inside the same sub object (containing its value).\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      // TODO could make \"fieldName\" and \"value\" configurable\n      if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n    var propertyGroup = \"\";\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return { group: propertyGroup, groupWithoutArrayIndices: propertyGroupWithoutArrayIndices, name: propertyName };\n  }\n\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n    return mapObject;\n  }\n\n  return Resolver;\n}());\n","\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\nvar internal_object_tools = module.exports={}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n    if (Object(cur) !== cur) {\n      result.push({ name: prop, value: cur });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n      if (l === 0) {\n        result[prop] = [];\n        result.push({ name: prop, value: \"\" });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n      if (isEmpty && prop) {\n        result.push({ name: prop, value: \"\" });\n      }\n    }\n  }\n  recurse(data, \"\", 0);\n  return result;\n};\n"],"names":["$03246337b2ee5537$var$module","$03246337b2ee5537$var$templateResolverInternalCreateIfNotExists","objectToCheck","$03246337b2ee5537$var$template_resolver","exports","internalCreateIfNotExists","$03246337b2ee5537$var$internal_object_tools","parcelRequire","Resolver","removeArrayBracketsRegEx","RegExp","getPropertyNameInfos","fullPropertyName","positionOfRightMostSeparator","lastIndexOf","propertyName","substr","propertyGroup","propertyGroupWithoutArrayIndices","replace","group","groupWithoutArrayIndices","name","addToFilteredMapObject","elements","mapObject","filterMatchesFunction","index","element","length","value","sourceDataObject","this","resolveTemplate","template","replaceResolvableFields","map","i","propertyInfo","propertyValue","propertyNames","Object","keys","addFieldsPerGroup","resolvableFieldsOfAll","ignoreInternalFields","indexOf","arguments","flattenToArray","stringContainingVariables","resolvableFields","replaced","propertyIndex","$4ee7050bd023907f$var$module","data","maxRecursionDepth","result","recurse","cur","prop","depth","push","Array","isArray","l","p","isEmpty"],"version":3,"file":"templateResolver.js.map","sourceRoot":"../"}