{"version":3,"sources":["../../lib/js/flattenToArray.js","templateResolver.js"],"names":["module","internal_object_tools","exports","flattenToArray","data","maxRecursionDepth","result","recurse","cur","prop","depth","Object","push","name","value","Array","isArray","i","l","length","isEmpty","p","template_resolver","require","Resolver","removeArrayBracketsRegEx","RegExp","getPropertyNameInfos","fullPropertyName","positionOfRightMostSeparator","lastIndexOf","propertyName","substr","propertyGroup","propertyGroupWithoutArrayIndices","replace","group","groupWithoutArrayIndices","addToFilteredMapObject","elements","mapObject","filterMatchesFunction","index","element","sourceDataObject","resolveTemplate","template","replaceResolvableFields","addFieldsPerGroup","map","propertyNames","propertyInfo","propertyValue","keys","resolvableFieldsOfAll","ignoreInternalFields","indexOf","arguments","stringContainingVariables","resolvableFields","replaced","propertyIndex"],"mappings":"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","file":"templateResolver.js","sourceRoot":"../src/js","sourcesContent":["\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\nvar internal_object_tools = module.exports={}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n    if (Object(cur) !== cur) {\n      result.push({ name: prop, value: cur });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n      if (l === 0) {\n        result[prop] = [];\n        result.push({ name: prop, value: \"\" });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n      if (isEmpty && prop) {\n        result.push({ name: prop, value: \"\" });\n      }\n    }\n  }\n  recurse(data, \"\", 0);\n  return result;\n};\n","/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */\nvar template_resolver = (module.exports = {}); // Export module for npm...\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\n/**\n * Resolver. Is used inside this repository. It could also be used outside.\n */\ntemplate_resolver.Resolver = (function () {\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Constructor function and container for everything, that needs to exist per instance.\n   * @constructs Resolver\n   */\n  function Resolver(sourceDataObject) {\n    this.sourceDataObject = sourceDataObject;\n    /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */\n    this.resolveTemplate = function (template) {\n      return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n    };\n    /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     */\n    this.resolvableFieldsOfAll = function () {\n      var map = {};\n      var ignoreInternalFields = function (propertyName) {\n        return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n      };\n      var index;\n      for (index = 0; index < arguments.length; index += 1) {\n        addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n      }\n      return map;\n    };\n    /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */\n    this.replaceResolvableFields = function (stringContainingVariables, resolvableFields) {\n      var replaced = stringContainingVariables;\n      var propertyNames = Object.keys(resolvableFields);\n      var propertyIndex = 0;\n      var propertyName = \"\";\n      var propertyValue = \"\";\n      for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n        propertyName = propertyNames[propertyIndex];\n        propertyValue = resolvableFields[propertyName];\n        replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n      }\n      return replaced;\n    };\n  }\n\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   */\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName);\n      // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n      // and a property named \"value\" inside the same sub object (containing its value).\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      // TODO could make \"fieldName\" and \"value\" configurable\n      if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   */\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n    var propertyGroup = \"\";\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return { group: propertyGroup, groupWithoutArrayIndices: propertyGroupWithoutArrayIndices, name: propertyName };\n  }\n\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   */\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n    return mapObject;\n  }\n\n  /**\n   * Public interface\n   * @scope template_resolver.Resolver\n   */\n  return Resolver;\n})();\n"]}