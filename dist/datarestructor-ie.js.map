{"version":3,"sources":["../../lib/js/polyfills/isArrayPolyfill.js","../../lib/js/polyfills/arrayFilterPolyfill.js","../../lib/js/polyfills/indexOfPolyfill.js","../../lib/js/polyfills/objectKeysPolyfill.js","../../lib/js/flattenToArray.js","datarestructor.js","datarestructor-ie.js"],"names":["Array","isArray","arg","Object","prototype","toString","call","filter","func","thisArg","TypeError","len","kValue","length","res","t","c","i","undefined","indexOf","max","min","member","fromIndex","that","Len","Math","keys","o","k","p","hasOwnProperty","push","module","internal_object_tools","exports","flattenToArray","data","maxRecursionDepth","result","recurse","cur","prop","depth","name","value","l","isEmpty","datarestructor","require","PropertyStructureDescriptionBuilder","createNameExtractFunction","description","isSpecifiedString","propertyName","propertyPatternTemplateMode","patternToMatch","propertyPattern","extractNameUsingTemplatePattern","regex","templateModePatternRegexForPatternAndVariable","match","exec","rightMostPropertyNameElement","extractNameUsingRightMostPropertyNameElement","regularExpression","RegExp","propertyPatternToUse","variablePattern","pattern","escapeCharsForRegEx","replace","characters","nonWordCharactersRegEx","withDefault","defaultValue","PropertyStructureDescription","type","category","abbreviation","image","indexStartsWith","groupName","groupPattern","groupDestinationPattern","groupDestinationName","deduplicationPattern","getDisplayNameForPropertyName","getFieldNameForPropertyName","matchesPropertyName","propertyPatternEqualMode","displayPropertyName","nameExtractFunction","upperCaseFirstLetterForFunction","upperCaseFirstLetter","charAt","toUpperCase","slice","removeArrayValuePropertyPostfixFunction","fieldName","build","propertyPatternToMatch","propertyNameWithoutArrayIndices","templateModePatternRegexForPattern","placeholderInDoubleCurlyBracketsRegEx","createFunctionMatchesPropertyName","DescribedEntryCreator","removeArrayBracketsRegEx","resolvableFieldsOfAll","varArgs","map","ignoreInternalFields","index","arguments","addToFilteredMapObject","getPropertyNameInfos","fullPropertyName","positionOfRightMostSeparator","lastIndexOf","substr","propertyGroup","propertyGroupWithoutArrayIndices","group","groupWithoutArrayIndices","replaceResolvableFields","stringContainingVariables","resolvableFields","replaced","propertyNames","propertyIndex","propertyValue","elements","mapObject","filterMatchesFunction","element","DescribedEntry","entry","indices","arrayBracketsRegEx","indicesOfWithRegex","regexWithOneNumberGroup","pointDelimited","numberArray","parseInt","displayName","_isMatchingIndex","_description","_identifier","propertyNameWithArrayIndices","groupId","groupDestinationId","deduplicationId","resolveTemplate","template","addFieldsPerGroup","propertyInfo","publicFieldsJson","space","propertyNamesWithoutObjectsAndFunctions","obj","prettyPrintJsonSpace","JSON","stringify","replacerRetainsOnlyDefinedPublicFields","key","onlyDefinedPublicFields","clonedEntry","clonedArray","Restructor","mergeFlattenedData","entries","entriesToMerge","idOfElementFunction","entriesToMergeById","asIdBasedObject","idIndexedObject","merged","id","deduplicateFlattenedData","extractEntriesByDescription","flattenedData","filtered","describedEntry","processJsonUsingDescriptions","jsonData","descriptions","debugMode","processedData","trailingArrayIndexRegEx","lastArrayProperty","lastArrayPropertyValue","propertyNameWithoutTrailingArrayIndex","console","log","describedData","descriptionIndex","propertiesAsArray","groupedData","applyGroupDestinationPattern","groupedObject","keysToDelete","destinationKey","newGroup","existingGroup","updatedGroup","concat","keyToDelete","groupFlattenedData","groupById","groupIdOfElementFunction","groupNameOfElementFunction","groupedResult"],"mappings":"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","file":"datarestructor-ie.js","sourceRoot":"../src/js","sourcesContent":["// https://gist.github.com/brianonn/4ef965a06b9e950d80e4e8b8e4c527f9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}","// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill\nif (!Array.prototype.filter){\n    Array.prototype.filter = function(func, thisArg) {\n      'use strict';\n      if ( ! ((typeof func === 'Function' || typeof func === 'function') && this) )\n          throw new TypeError();\n     \n      var len = this.length >>> 0,\n          res = new Array(len), // preallocate array\n          t = this, c = 0, i = -1;\n  \n      var kValue;\n      if (thisArg === undefined){\n        while (++i !== len){\n          // checks to see if the key was set\n          if (i in this){\n            kValue = t[i]; // in case t is changed in callback\n            if (func(t[i], i, t)){\n              res[c++] = kValue;\n            }\n          }\n        }\n      }\n      else{\n        while (++i !== len){\n          // checks to see if the key was set\n          if (i in this){\n            kValue = t[i];\n            if (func.call(thisArg, t[i], i, t)){\n              res[c++] = kValue;\n            }\n          }\n        }\n      }\n     \n      res.length = c; // shrink down array to proper size\n      return res;\n    };\n  }","//https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\nif (!Array.prototype.indexOf)  Array.prototype.indexOf = (function(Object, max, min){\n    \"use strict\";\n    return function indexOf(member, fromIndex) {\n      if(this===null||this===undefined)throw TypeError(\"Array.prototype.indexOf called on null or undefined\");\n      \n      var that = Object(this), Len = that.length >>> 0, i = min(fromIndex | 0, Len);\n      if (i < 0) i = max(0, Len+i); else if (i >= Len) return -1;\n      \n      if(member===void 0){ for(; i !== Len; ++i) if(that[i]===void 0 && i in that) return i; // undefined\n      }else if(member !== member){   for(; i !== Len; ++i) if(that[i] !== that[i]) return i; // NaN\n      }else                           for(; i !== Len; ++i) if(that[i] === member) return i; // all else\n  \n      return -1; // if the value was not found, then return -1\n    };\n  })(Object, Math.max, Math.min);","//http://tokenposts.blogspot.com/2012/04/javascript-objectkeys-browser.html\nif (!Object.keys) Object.keys = function(o) {\n    if (o !== Object(o))\n      throw new TypeError('Object.keys called on a non-object');\n    var k=[],p;\n    for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p);\n    return k;\n  }","\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\nvar internal_object_tools = module.exports={}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n    if (Object(cur) !== cur) {\n      result.push({ name: prop, value: cur });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n      if (l === 0) {\n        result[prop] = [];\n        result.push({ name: prop, value: \"\" });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n      if (isEmpty && prop) {\n        result.push({ name: prop, value: \"\" });\n      }\n    }\n  }\n  recurse(data, \"\", 0);\n  return result;\n};\n","/**\n * @fileOverview datarestructor Transforms parsed JSON objects into a uniform data structure\n * @version ${project.version}\n */\n\n \"use strict\";\nvar module = module || {}; // Fallback for vanilla js without modules\n\n//TODO must require internal_object_tools.flattenToArray\n//TODO fallback for \"vanilla js\" = include all scripts separatly\n/**\n * datarestructor namespace declaration.\n * It contains all functions to convert an object (e.g. parsed JSON) into uniform enumerated list of described field entries.\n * Workflow: JSON -> flatten -> mark and identify -> add array fields -> deduplicate -> group -> flatten again\n * @default {}\n */\nvar datarestructor = module.exports={}; // Export module for npm...\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\n/**\n * @callback propertyNameFunction\n *  @param {string} propertyname\n */\n\n/**\n * @typedef {Object} PropertyStructureDescription\n * @property {string} type - \"\"(default). Some examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n * @property {string} category - name of the category. Default = \"\". Could contain a symbol character or a short domain name. (e.g. \"city\")\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {boolean} propertyPatternTemplateMode - \"false\"(default): property name needs to be equal to the pattern. \"true\" allows variables like \"{{fieldName}}\" inside the pattern.\n * @property {string} propertyPattern - property name pattern (without array indices) to match\n * @property {string} indexStartsWith - \"\"(default) matches all ids. String that needs to match the beginning of the id. E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n * @property {propertyNameFunction} getDisplayNameForPropertyName - display name for the property. \"\"(default) last property name element with upper case first letter.\n * @property {propertyNameFunction} getFieldNameForPropertyName - field name for the property. \"\" (default) last property name element.\n * @property {string} groupName - name of the property, that contains grouped entries. Default=\"group\".\n * @property {string} groupPattern - Pattern that describes how to group entries. \"groupName\" defines the name of this group. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationPattern - Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationName - (default=groupName) Name of the group when it had been moved to the destination.\n * @property {string} deduplicationPattern - Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n */\n\n/**\n * PropertyStructureDescriptionBuilder\n *\n * @namespace\n */\ndatarestructor.PropertyStructureDescriptionBuilder = (function () {\n  \"use strict\";\n\n  /**\n   * Constructor function and container for everything, that needs to exist per instance.\n   */\n  function PropertyStructureDescription() {\n    this.description = {\n      type: \"\",\n      category: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      propertyPatternTemplateMode: false,\n      propertyPattern: \"\",\n      indexStartsWith: \"\",\n      groupName: \"group\",\n      groupPattern: \"\",\n      groupDestinationPattern: \"\",\n      groupDestinationName: null,\n      deduplicationPattern: \"\",\n      getDisplayNameForPropertyName: null,\n      getFieldNameForPropertyName: null,\n      matchesPropertyName: null\n    };\n    this.type = function (value) {\n      this.description.type = value;\n      return this;\n    };\n    this.category = function (value) {\n      this.description.category = value;\n      return this;\n    };\n    this.abbreviation = function (value) {\n      this.description.abbreviation = withDefault(value, \"\");\n      return this;\n    };\n    this.image = function (value) {\n      this.description.image = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * \"propertyPattern\" need to match exactly if this mode is activated.\n     *  It clears propertyPatternTemplateMode which means \"equal\" mode.\n     */\n    this.propertyPatternEqualMode = function () {\n      this.description.propertyPatternTemplateMode = false;\n      return this;\n    };\n    /**\n     * \"propertyPattern\" can contain variables like {{fieldName}} and\n     * doesn't need to match the property name exactly. If the \"propertyPattern\"\n     * is shorter than the property name, it also matches when the property name\n     * starts with the \"propertyPattern\".\n     */\n    this.propertyPatternTemplateMode = function () {\n      this.description.propertyPatternTemplateMode = true;\n      return this;\n    };\n    /**\n     * property name pattern (single property names with sub types separated by \".\" without array indices) to match.\n     * May contain variables in double curly brackets.\n     * Example: responses.hits.hits._source.{{fieldName}}\n     * @returns {PropertyStructureDescription}\n     */\n    this.propertyPattern = function (value) {\n      this.description.propertyPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     *  String that needs to match the beginning of the id.\n     *  E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n     *  Default is \"\" which will match every id.\n     */\n    this.indexStartsWith = function (value) {\n      this.description.indexStartsWith = withDefault(value, \"\");\n      return this;\n    };\n    this.displayPropertyName = function (value) {\n      this.description.getDisplayNameForPropertyName = createNameExtractFunction(value, this.description);\n      if (isSpecifiedString(value)) {\n        return this;\n      }\n      this.description.getDisplayNameForPropertyName = removeArrayValuePropertyPostfixFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      this.description.getDisplayNameForPropertyName = upperCaseFirstLetterForFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      return this;\n    };\n    this.fieldName = function (value) {\n      this.description.getFieldNameForPropertyName = createNameExtractFunction(value, this.description);\n      return this;\n    };\n    this.groupName = function (value) {\n      this.description.groupName = withDefault(value, \"\");;\n      return this;\n    };\n    /**\n     * Pattern that describes how to group entries. \"groupName\" defines the name of this group.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     */\n    this.groupPattern = function (value) {\n      this.description.groupPattern = withDefault(value, \"\");;\n      return this;\n    };\n    /**\n     * Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     */\n    this.groupDestinationPattern = function (value) {\n      this.description.groupDestinationPattern = withDefault(value, \"\");;\n      return this;\n    };\n    /**\n     * Name of the group when it had been moved to the destination.\n     * The default value is the groupName, which will be used when the value is not valid (null or empty)\n     */\n    this.groupDestinationName = function (value) {\n      this.description.groupDestinationName = withDefault(value, this.description.groupName);\n      return this;\n    };\n    /**\n     * Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     */\n    this.deduplicationPattern = function (value) {\n      this.description.deduplicationPattern = withDefault(value, \"\");;\n      return this;\n    };\n    this.build = function () {\n      this.description.matchesPropertyName = createFunctionMatchesPropertyName(this.description);\n      if (this.description.getDisplayNameForPropertyName == null) {\n        this.displayPropertyName(\"\");\n      }\n      if (this.description.getFieldNameForPropertyName == null) {\n        this.fieldName(\"\");\n      }\n      if (this.description.groupDestinationName == null) {\n        this.groupDestinationName(\"\");\n      }\n      return this.description;\n    };\n  }\n\n  function createNameExtractFunction(value, description) {\n    if (isSpecifiedString(value)) {\n      return function (propertyName) {\n        return value;\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      var patternToMatch = description.propertyPattern; // closure (closed over) parameter\n      return extractNameUsingTemplatePattern(patternToMatch);\n    }\n    return extractNameUsingRightMostPropertyNameElement();\n  }\n\n  function createFunctionMatchesPropertyName(description) {\n    var propertyPatternToMatch = description.propertyPattern; // closure (closed over) parameter\n    if (!isSpecifiedString(propertyPatternToMatch)) {\n      return function (propertyNameWithoutArrayIndices) {\n        return false; // Without a propertyPattern, no property will match (deactivated mark/identify).\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      return function (propertyNameWithoutArrayIndices) {\n        return templateModePatternRegexForPattern(propertyPatternToMatch).exec(propertyNameWithoutArrayIndices) != null;\n      };\n    }\n    return function (propertyNameWithoutArrayIndices) {\n      return propertyNameWithoutArrayIndices === propertyPatternToMatch;\n    };\n  }\n\n  function rightMostPropertyNameElement(propertyName) {\n    var regularExpression = new RegExp(\"(\\\\w+)$\", \"gi\");\n    var match = propertyName.match(regularExpression);\n    if (match != null) {\n      return match[0];\n    }\n    return propertyName;\n  }\n\n  function upperCaseFirstLetter(value) {\n    if (value.length > 1) {\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    }\n    return value;\n  }\n\n  function upperCaseFirstLetterForFunction(nameExtractFunction) {\n    return function (propertyName) {\n      return upperCaseFirstLetter(nameExtractFunction(propertyName));\n    };\n  }\n\n  function removeArrayValuePropertyPostfixFunction(nameExtractFunction) {\n    return function (propertyName) {\n      var name = nameExtractFunction(propertyName);\n      name = name != null ? name : \"\";\n      return name.replace(\"_comma_separated_values\", \"\");\n    };\n  }\n\n  function extractNameUsingTemplatePattern(propertyPattern) {\n    return function (propertyName) {\n      var regex = templateModePatternRegexForPatternAndVariable(propertyPattern, \"{{fieldName}}\");\n      var match = regex.exec(propertyName);\n      if (match && match[1] != \"\") {\n        return match[1];\n      }\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function extractNameUsingRightMostPropertyNameElement() {\n    return function (propertyName) {\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function templateModePatternRegexForPattern(propertyPatternToUse) {\n    var placeholderInDoubleCurlyBracketsRegEx = new RegExp(\"\\\\\\\\\\\\{\\\\\\\\\\\\{[-\\\\w]+\\\\\\\\\\\\}\\\\\\\\\\\\}\", \"gi\");\n    return templateModePatternRegexForPatternAndVariable(propertyPatternToUse, placeholderInDoubleCurlyBracketsRegEx);\n  }\n\n  function templateModePatternRegexForPatternAndVariable(propertyPatternToUse, variablePattern) {\n    var pattern = escapeCharsForRegEx(propertyPatternToUse);\n    if (typeof variablePattern === \"string\") {\n      variablePattern = escapeCharsForRegEx(variablePattern);\n    }\n    pattern = pattern.replace(variablePattern, \"([-\\\\w]+)\");\n    pattern = \"^\" + pattern;\n    return new RegExp(pattern, \"i\");\n  }\n\n  function escapeCharsForRegEx(characters) {\n    var nonWordCharactersRegEx = new RegExp(\"([^-\\\\w])\", \"gi\");\n    return characters.replace(nonWordCharactersRegEx, \"\\\\$1\");\n  }\n\n  function withDefault(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value != null && value != \"\";\n  }\n\n  /**\n   * Public interface\n   * @scope datarestructor.PropertyStructureDescriptionBuilder\n   */\n  return PropertyStructureDescription;\n})();\n\n/**\n * @typedef {Object} DescribedEntry\n * @property {string} category - category of the result from the PropertyStructureDescription using a short name or e.g. a symbol character\n * @property {string} type - type of the result from PropertyStructureDescription\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the split index. Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with the two elements: [2,4]\n * @property {string} displayName - display name extracted from the point separated hierarchical property name, e.g. \"Name\"\n * @property {string} fieldName - field name extracted from the point separated hierarchical property name, e.g. \"name\"\n * @property {string} value - content of the field\n * @property {string} resolveTemplate - function, that replaces propertyNames in double curly brackets with the values in this object.\n * @property {string} publicFieldsJson - function, that converts the public fields including grouped sub structures to JSON.\n * @property {boolean} _isMatchingIndex - true, when _identifier.index matches the described \"indexStartsWith\"\n * @property {Object} _identifier - internal structure for identifier. Avoid using it outside since it may change.\n * @property {string} _identifier.index - array indices in hierarchical order separated by points, e.g. \"0.0\"\n * @property {string} _identifier.value - the (single) value of the \"flattened\" property, e.g. \"Smith\"\n * @property {string} _identifier.propertyNameWithArrayIndices - the \"original\" flattened property name in hierarchical order separated by points, e.g. \"responses[0].hits.hits[0]._source.name\"\n * @property {string} _identifier.propertyNameWithoutArrayIndices - same as propertyNamesWithArrayIndices but without array indices, e.g. \"responses.hits.hits._source.name\"\n * @property {string} _identifier.groupId - Contains the resolved groupPattern from the PropertyStructureDescription. Entries with the same id will be grouped into the \"groupName\" of the PropertyStructureDescription.\n * @property {string} _identifier.groupDestinationId - Contains the resolved groupDestinationPattern from the PropertyStructureDescription. Entries with this id will be moved to the given destination group.\n * @property {string} _identifier.deduplicationId - Contains the resolved deduplicationPattern from the PropertyStructureDescription. Entries with the same id will be considered to be a duplicate and hence removed.\n * @property {Object} _description - PropertyStructureDescription for internal use. Avoid using it outside since it may change.\n */\n\n/**\n * @callback stringFieldOfDescribedEntryFunction\n *  @param {DescribedEntry} entry\n */\n\n/**\n * DescribedEntryCreator\n *\n * @namespace\n */\ndatarestructor.DescribedEntryCreator = (function () {\n  \"use strict\";\n\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Constructor function and container for everything, that needs to exist per instance.\n   */\n  function DescribedEntry(entry, description) {\n    var indices = indicesOf(entry.name);\n    var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n\n    this.category = description.category;\n    this.type = description.type;\n    this.abbreviation = description.abbreviation;\n    this.image = description.image;\n    /**\n     * Array of numbers containing the split index. \n     * Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with two elements: [2,4]\n     * This is the public version of the internal variable _identifier.index, which contains in contrast all index elements in one point separated string (e.g. \"2.4\").\n     */\n    this.index = indices.numberArray;\n    this.displayName = description.getDisplayNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.fieldName = description.getFieldNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.value = entry.value;\n    this._isMatchingIndex = indices.pointDelimited.indexOf(description.indexStartsWith) == 0;\n    this._description = description;\n\n    this._identifier = {\n      index: indices.pointDelimited,\n      propertyNameWithArrayIndices: entry.name,\n      propertyNameWithoutArrayIndices: propertyNameWithoutArrayIndices,\n      groupId: \"\",\n      groupDestinationId: \"\",\n      deduplicationId: \"\"\n    };\n    this._identifier.groupId = replaceResolvableFields(\n      description.groupPattern,\n      resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.groupDestinationId = replaceResolvableFields(\n      description.groupDestinationPattern,\n      resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.deduplicationId = replaceResolvableFields(\n      description.deduplicationPattern,\n      resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    /**\n     * Resolves the given template.\n     * \n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\" \n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     * \n     * @param {string} template\n     * @returns {string} resolved template\n     */\n    this.resolveTemplate = function (template) {\n      return replaceResolvableFields(template, addFieldsPerGroup(resolvableFieldsOfAll(this)));\n    };\n\n    /**\n     * Returns JSON containing all the public fields\n     * @param space — Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    this.publicFieldsJson = function (space) {\n      var propertyNames = propertyNamesWithoutObjectsAndFunctions(this);\n      var prettyPrintJsonSpace = typeof space === \"number\" ? space : 0;\n      return JSON.stringify(this, replacerRetainsOnlyDefinedPublicFields(propertyNames), prettyPrintJsonSpace);\n    };\n  }\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {String} fullPropertyName\n   * @return {ExtractedIndices} extracted indices in different representations\n   */\n  function indicesOf(fullPropertyName) {\n    var arrayBracketsRegEx = new RegExp(\"\\\\[(\\\\d+)\\\\]\", \"gi\");\n    return indicesOfWithRegex(fullPropertyName, arrayBracketsRegEx);\n  }\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {string} fullPropertyName\n   * @param {RegExp} regexWithOneNumberGroup\n   * @return {ExtractedIndices} extracted indices in different representations\n   */\n  function indicesOfWithRegex(fullPropertyName, regexWithOneNumberGroup) {\n    var pointDelimited = \"\";\n    var numberArray = [];\n    var match;\n    do {\n      match = regexWithOneNumberGroup.exec(fullPropertyName);\n      if (match) {\n        if (pointDelimited.length > 0) {\n          pointDelimited += \".\";\n        }\n        pointDelimited += match[1];\n        numberArray.push(parseInt(match[1]));\n      }\n    } while (match);\n    return { pointDelimited: pointDelimited, numberArray: numberArray };\n  }\n\n  /**\n   * Returns a map like object, that contains all resolvable fields and their values as properties.\n   * This function takes a variable count of input parameters, \n   * each containing an object that contains resolvable fields to extract from.\n   * \n   * The recursion depth is limited to 3, so that an object, \n   * that contains an object can contain another object (but not further).\n   * \n   * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n   * \n   * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables. \n   * @returns {object} object with resolvable field names and their values.\n   */\n  function resolvableFieldsOfAll(varArgs) {\n    var map = {};\n    var ignoreInternalFields = function (propertyName) {\n      return (propertyName.indexOf(\"_\") != 0) && (propertyName.indexOf(\"._\") < 0);\n    };\n    for (var index = 0; index < arguments.length; index+=1) {\n      addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n    }\n    return map;\n  }\n\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   */\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName);\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      if (propertyInfo.name == \"fieldName\" && propertyValue != \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself. \n   * @param {String} fullPropertyName \n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   */\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n    var propertyGroup = \"\";\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return {group: propertyGroup, groupWithoutArrayIndices: propertyGroupWithoutArrayIndices, name: propertyName};\n  }\n\n  /**\n   * Replaces all variables in double curly brackets, e.g. {{property}},\n   * with the value of that property from the resolvableProperties.\n   *\n   * Supported property types: string, number, boolean\n   * @param {string} stringContainingVariables\n   * @param {object[]} resolvableFields (name=value)\n   */\n  function replaceResolvableFields(stringContainingVariables, resolvableFields) {\n    var replaced = stringContainingVariables;\n    var propertyNames = Object.keys(resolvableFields);\n    var propertyIndex = 0;\n    var propertyName = \"\";\n    var propertyValue = \"\";\n    for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n      propertyName = propertyNames[propertyIndex];\n      propertyValue = resolvableFields[propertyName];\n      replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n    }\n    return replaced;\n  }\n\n  /**\n   * Returns an array of property names of the given object without properties of type \"object\".\n   */\n  function propertyNamesWithoutObjectsAndFunctions(obj) {\n    var result = [];\n    var propertyIndex;\n    var propertyName;\n    var propertyNames = Object.keys(obj);\n    for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n      propertyName = propertyNames[propertyIndex];\n      if (typeof obj[propertyName] !== \"object\" && typeof obj[propertyName] !== \"function\") {\n        result.push(propertyName);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns a function, that takes two arguments and is therefore applicable to be used as \"replacer\" parameter for JSON.stringify.\n   * It only retains the given property names and removes everything else except for embedded \"sub\" objects\n   * with the same structure (and only one recursive level). These sub objects will be cloned to get rid of the circular\n   * structure that would lead to the error message \"TypeError: Converting circular structure to JSON\".\n   * Internal properties containing objects but beginning with an underscore in their name will also be removed.\n   *\n   * @param key name of the property to be converted to JSON or empty for the whole object.\n   * @param value value of the property to be converted to JSON.\n   * @returns function that is applicable to be used as \"replacer\" parameter for JSON.stringify.\n   */\n  function replacerRetainsOnlyDefinedPublicFields(propertyNames) {\n    return function (key, value) {\n      return onlyDefinedPublicFields(key, value, propertyNames);\n    };\n  }\n  /**\n   * This function takes two arguments and is therefore applicable to be used as \"replacer\" parameter for JSON.stringify.\n   * It removes internal properties beginning with an underscore in their name\n   * and creates new objects for grouped structures (only one recursion level) to get rid of the circular structure\n   * that would lead to the error message \"TypeError: Converting circular structure to JSON\".\n   *\n   * @param {string} key name of the property to be converted to JSON or empty for the whole object.\n   * @param {string} value value of the property to be converted to JSON.\n   * @param {string[]} propertyNames array of strings containing only the public fields that will be converted to JSON.\n   */\n  function onlyDefinedPublicFields(key, value, propertyNames) {\n    if (typeof value !== \"object\" && propertyNames.indexOf(key) < 0 && key != \"\") {\n      return undefined; // Remove all properties that are not contained in the given list.\n    }\n    if (key.indexOf(\"_\") == 0) {\n      return undefined; //Remove all properties with a name beginning with an underscore (internal fields).\n    }\n    if (Array.isArray(value)) {\n      var index, propertyIndex;\n      var entry, clonedEntry;\n      var clonedArray = [];\n      for (index = 0; index < value.length; index += 1) {\n        entry = value[index];\n        clonedEntry = {};\n        for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n          clonedEntry[propertyNames[propertyIndex]] = entry[propertyNames[propertyIndex]];\n        }\n        clonedArray.push(clonedEntry);\n      }\n      return clonedArray;\n    }\n    return value;\n  }\n\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   * \n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`. \n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   */\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n    return mapObject;\n  }\n\n  /**\n   * Public interface\n   * @scope datarestructor.DescribedEntryCreator\n   */\n  return DescribedEntry;\n})();\n\ndatarestructor.Restructor = (function () {\n  \"use strict\";\n\n  /**\n   * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n   * Workflow: JSON -> flatten -> mark and identify -> add array fields -> deduplicate -> group -> flatten again\n   * @param {object} jsonData - parsed JSON data or any other data object\n   * @param {PropertyStructureDescription[]} descriptions - already grouped entries\n   * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n   */\n  function processJsonUsingDescriptions(jsonData, descriptions, debugMode) {\n    // \"Flatten\" the hierarchical input json to an array of property names (point separated \"folders\") and values.\n    var processedData = internal_object_tools.flattenToArray(jsonData);\n    // Fill in properties ending with the name \"_comma_separated_values\" for array values to make it easier to display them.\n    processedData = fillInArrayValues(processedData);\n\n    if ((typeof debugMode === \"boolean\") && debugMode) {\n      console.log(\"flattened data with array values:\");\n      console.log(processedData);\n    }\n\n    // Mark, identify and harmonize the flattened data by applying one description after another in their given order.\n    var describedData = [];\n    for (var descriptionIndex = 0; descriptionIndex < descriptions.length; descriptionIndex++) {\n      var description = descriptions[descriptionIndex];\n      // Filter all entries that match the current description and enrich them with it\n      var dataWithDescription = extractEntriesByDescription(processedData, description);\n      // Remove duplicate entries where a deduplicationPattern is described\n      describedData = deduplicateFlattenedData(describedData, dataWithDescription);\n    }\n    processedData = describedData;\n\n    // Group entries where a groupPattern is described\n    processedData = groupFlattenedData(processedData);\n\n    // Move group entries where a groupDestinationPattern is described\n    processedData = applyGroupDestinationPattern(processedData);\n\n    // Turns the grouped object back into an array of DescribedEntry-Objects\n    return propertiesAsArray(processedData);\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries that occur later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * The id is extracted from every element using the given function.\n   *\n   * @param {DescribedEntry[]} entries\n   * @param {DescribedEntry[]} entriesToMerge\n   * @param {stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   */\n  function mergeFlattenedData(entries, entriesToMerge, idOfElementFunction) {\n    var entriesToMergeById = asIdBasedObject(entriesToMerge, idOfElementFunction);\n    var merged = [];\n    for (var index = 0; index < entries.length; index++) {\n      var entry = entries[index];\n      var id = idOfElementFunction(entry);\n      if (id == null || id === \"\" || entriesToMergeById[id] == null) {\n        merged.push(entry);\n      }\n    }\n    for (var index = 0; index < entriesToMerge.length; index++) {\n      var entry = entriesToMerge[index];\n      merged.push(entry);\n    }\n    return merged;\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries occurring later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * \"entriesToMerge\" will be returned directly, if \"entries\" is null or empty.\n   *\n   * The id is extracted from every element using their deduplication pattern (if available).\n   *\n   * @param {DescribedEntry[]} entries\n   * @param {DescribedEntry[]} entriesToMerge\n   * @param {stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @see mergeFlattenedData\n   */\n  function deduplicateFlattenedData(entries, entriesToMerge) {\n    if (entries == null || entries.length == 0) {\n      return entriesToMerge;\n    }\n    var idOfElementFunction = function (entry) {\n      return entry._identifier.deduplicationId;\n    };\n    return mergeFlattenedData(entries, entriesToMerge, idOfElementFunction);\n  }\n\n  /**\n   * Converts the given elements to an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1.\n   * @param {DescribedEntry[]} elements of DescribedEntry elements\n   * @param {stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @return {DescribedEntry[] entries indexed by id\n   */\n  function asIdBasedObject(elements, idOfElementFunction) {\n    var idIndexedObject = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      idIndexedObject[idOfElementFunction(element)] = element;\n    }\n    return idIndexedObject;\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id (determined by the entry's groupPattern).\n   * For example, [{id: A, value: 1}] becomes result['A'] = 1.\n   *\n   * Furthermore, this function creates a group property (determined by the entry's groupName)\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {DescribedEntry[]} elements of DescribedEntry elements\n   * @return {DescribedEntry[] entries indexed by id\n   */\n  function groupFlattenedData(flattenedData) {\n    return groupById(\n      flattenedData,\n      function (entry) {\n        return entry._identifier.groupId;\n      },\n      function (entry) {\n        return entry._description.groupName;\n      }\n    );\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1. Furthermore, this function creates a group property (with the name )\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {DescribedEntry[]} elements of DescribedEntry elements\n   * @param {stringFieldOfDescribedEntryFunction} groupNameOfElementFunction function, that returns the name of the group property that will be created inside the \"main\" element.\n   * @param {stringFieldOfDescribedEntryFunction} groupIdOfElementFunction returns the group id of an DescribedEntry\n   * @return {DescribedEntry[] entries indexed by id\n   */\n  function groupById(elements, groupIdOfElementFunction, groupNameOfElementFunction) {\n    var groupedResult = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      var groupId = groupIdOfElementFunction(element);\n      if (groupId === \"\") {\n        continue;\n      }\n      var groupName = groupNameOfElementFunction(element);\n      if (groupName == null || groupName === \"\") {\n        continue;\n      }\n      if (!groupedResult[groupId]) {\n        groupedResult[groupId] = element;\n        groupedResult[groupId][groupName] = [];\n      }\n      groupedResult[groupId][groupName].push(element);\n    }\n    return groupedResult;\n  }\n\n  /**\n   * Extracts entries out of \"flattened\" JSON data and provides an array of objects.\n   * @param {Object[]} flattenedData - flattened json from search query result\n   * @param {string} flattenedData[].name - name of the property in hierarchical order separated by points\n   * @param {string} flattenedData[].value - value of the property as string\n   * @param {PropertyStructureDescription} - description of structure of the entries that should be extracted\n   * @return {DescribedEntry[]}\n   */\n  function extractEntriesByDescription(flattenedData, description) {\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    var filtered = [];\n\n    flattenedData.filter(function (entry) {\n      var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n      if (description.matchesPropertyName(propertyNameWithoutArrayIndices)) {\n        var describedEntry = new datarestructor.DescribedEntryCreator(entry, description);\n        if (describedEntry._isMatchingIndex) {\n          filtered.push(describedEntry);\n        }\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * Takes already grouped {@link DescribedEntry} objects and\n   * uses their \"_identifier.groupDestinationId\" (if exists)\n   * to move groups to the given destination.\n   *\n   * This is useful, if separately described groups like \"summary\" and \"detail\" should be put together,\n   * so that every summery contains a group with the regarding details.\n   *\n   * @param {DescribedEntry[]} groupedObject - already grouped entries\n   * @return {DescribedEntry[]}\n   */\n  function applyGroupDestinationPattern(groupedObject) {\n    var keys = Object.keys(groupedObject);\n    var keysToDelete = [];\n    for (var index = 0; index < keys.length; index++) {\n      var key = keys[index];\n      var entry = groupedObject[key];\n      if (entry._description.groupDestinationPattern != \"\") {\n        var destinationKey = entry._identifier.groupDestinationId;\n        if (groupedObject[destinationKey] != null) {\n          var newGroup = entry[entry._description.groupName];\n          var existingGroup = groupedObject[destinationKey][entry._description.groupDestinationName]; //join if exists\n          var updatedGroup = existingGroup != null ? existingGroup.concat(newGroup) : newGroup;\n          groupedObject[destinationKey][entry._description.groupDestinationName] = updatedGroup;\n          keysToDelete.push(key);\n        }\n      }\n    }\n    // delete all moved entries that had been collected by their key\n    for (var index = 0; index < keysToDelete.length; index++) {\n      var keyToDelete = keysToDelete[index];\n      delete groupedObject[keyToDelete];\n    }\n    return groupedObject;\n  }\n\n  /**\n   * Fills in extra \"_comma_separated_values\" properties into the flattened data\n   * for properties that end with an array. E.g. response.hits.hits.tags[0]=\"active\" and response.hits.hits.tags[0]=\"ready\"\n   * will lead to the extra element \"response.hits.hits.tags_comma_separated_values=\"active, ready\".\n   *\n   * @return flattened data with filled in \"_comma_separated_values\" properties\n   */\n  function fillInArrayValues(flattenedData) {\n    var trailingArrayIndexRegEx = new RegExp(\"\\\\[\\\\d+\\\\]$\", \"gi\");\n    var result = [];\n    var lastArrayProperty = \"\";\n    var lastArrayPropertyValue = \"\";\n\n    flattenedData.filter(function (entry) {\n      if (!entry.name.match(trailingArrayIndexRegEx)) {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        result.push(entry);\n        return;\n      }\n      var propertyNameWithoutTrailingArrayIndex = entry.name.replace(trailingArrayIndexRegEx, \"\");\n      if (lastArrayProperty === propertyNameWithoutTrailingArrayIndex) {\n        lastArrayPropertyValue += \", \" + entry.value;\n      } else {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        lastArrayProperty = propertyNameWithoutTrailingArrayIndex;\n        lastArrayPropertyValue = entry.value;\n      }\n      result.push(entry);\n    });\n    return result;\n  }\n\n  /**\n   * @typedef {Object} ExtractedIndices\n   * @property {string} pointDelimited - bracket indices separated by points\n   * @property {number[]} numberArray as array of numbers\n   */\n  function propertiesAsArray(groupedData) {\n    var result = [];\n    var propertyNames = Object.keys(groupedData);\n    for (var propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex++) {\n      var propertyName = propertyNames[propertyIndex];\n      var propertyValue = groupedData[propertyName];\n      result.push(propertyValue);\n    }\n    return result;\n  }\n\n  /**\n   * Public interface\n   * @scope datarestructor.Restructor\n   */\n  return {\n    /**\n     * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n     * Workflow: JSON -> flatten -> mark and identify -> add array fields -> deduplicate -> group -> flatten again\n     * @param {object} jsonData - parsed JSON data or any other data object\n     * @param {PropertyStructureDescription[]} descriptions - already grouped entries\n     * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n     */\n    processJsonUsingDescriptions: processJsonUsingDescriptions\n  };\n})();","\"use strict\";\nrequire(\"../../lib/js/polyfills/isArrayPolyfill.js\");\nrequire(\"../../lib/js/polyfills/arrayFilterPolyfill.js\");\nrequire(\"../../lib/js/polyfills/indexOfPolyfill.js\");\nrequire(\"../../lib/js/polyfills/objectKeysPolyfill.js\");\nvar datarestructor = require(\"../../src/js/datarestructor.js\");\nmodule.exports= {datarestructor};\n"]}