{"version":3,"sources":["../../lib/js/polyfills/isArrayPolyfill.js","../../lib/js/polyfills/arrayFilterPolyfill.js","../../lib/js/polyfills/indexOfPolyfill.js","../../lib/js/polyfills/objectKeysPolyfill.js","../../lib/js/flattenToArray.js","templateResolver.js","describedfield.js","datarestructor.js","datarestructor-ie.js"],"names":["Array","isArray","arg","Object","prototype","toString","call","filter","func","thisArg","TypeError","len","kValue","length","res","t","c","i","undefined","indexOf","max","min","member","fromIndex","that","Len","Math","keys","o","k","p","hasOwnProperty","push","module","internal_object_tools","exports","flattenToArray","data","maxRecursionDepth","result","recurse","cur","prop","depth","name","value","l","isEmpty","templateResolverInternalCreateIfNotExists","objectToCheck","template_resolver","internalCreateIfNotExists","require","Resolver","removeArrayBracketsRegEx","RegExp","getPropertyNameInfos","fullPropertyName","positionOfRightMostSeparator","lastIndexOf","propertyName","substr","propertyGroup","propertyGroupWithoutArrayIndices","replace","group","groupWithoutArrayIndices","addToFilteredMapObject","elements","mapObject","filterMatchesFunction","index","element","sourceDataObject","resolveTemplate","template","replaceResolvableFields","addFieldsPerGroup","map","propertyNames","propertyInfo","propertyValue","resolvableFieldsOfAll","ignoreInternalFields","arguments","stringContainingVariables","resolvableFields","replaced","propertyIndex","describedFieldInternalCreateIfNotExists","described_field","DescribedDataFieldBuilder","withDefaultString","defaultValue","isSpecifiedString","withDefaultArray","describedField","category","type","abbreviation","image","groupNames","displayName","fieldName","fromDescribedDataField","build","copyWithoutGroups","describedDataField","DescribedDataFieldGroup","dataField","addGroupEntry","groupName","addGroupEntries","describedFields","datarestructorInternalCreateIfNotExists","datarestructor","PropertyStructureDescriptionBuilder","createNameExtractFunction","description","propertyPatternTemplateMode","patternToMatch","propertyPattern","extractNameUsingTemplatePattern","regex","templateModePatternRegexForPatternAndVariable","match","exec","rightMostPropertyNameElement","extractNameUsingRightMostPropertyNameElement","regularExpression","propertyPatternToUse","variablePattern","pattern","escapeCharsForRegEx","characters","nonWordCharactersRegEx","withDefault","PropertyStructureDescription","indexStartsWith","groupPattern","groupDestinationPattern","groupDestinationName","deduplicationPattern","getDisplayNameForPropertyName","getFieldNameForPropertyName","matchesPropertyName","propertyPatternEqualMode","displayPropertyName","nameExtractFunction","upperCaseFirstLetterForFunction","upperCaseFirstLetter","charAt","toUpperCase","slice","removeArrayValuePropertyPostfixFunction","propertyPatternToMatch","propertyNameWithoutArrayIndices","templateModePatternRegexForPattern","placeholderInDoubleCurlyBracketsRegEx","createFunctionMatchesPropertyName","DescribedEntryCreator","DescribedEntry","entry","indices","arrayBracketsRegEx","indicesOfWithRegex","regexWithOneNumberGroup","pointDelimited","numberArray","parseInt","templateResolver","_isMatchingIndex","_description","_identifier","propertyNameWithArrayIndices","groupId","groupDestinationId","deduplicationId","describedEntry","describedEntries","Transform","mergeFlattenedData","entries","entriesToMerge","idOfElementFunction","entriesToMergeById","id","asIdBasedObject","idIndexedObject","merged","deduplicateFlattenedData","extractEntriesByDescription","flattenedData","filtered","toDescribedField","recursionDepth","field","fieldGroups","forEachGroupEntry","rootEntry","onFoundEntry","groupIndex","entryIndex","groupEntry","descriptions","debugMode","enableDebugMode","setMaxRecursionDepth","processJson","processJsonUsingDescriptions","jsonData","processedData","trailingArrayIndexRegEx","lastArrayProperty","lastArrayPropertyValue","propertyNameWithoutTrailingArrayIndex","console","log","describedData","descriptionIndex","dataWithDescription","groupFlattenedData","groupById","groupIdOfElementFunction","groupNameOfElementFunction","groupedResult","applyGroupDestinationPattern","groupedObject","keysToDelete","key","destinationKey","newGroup","keyToDelete","toDescribedFields","describedEntity","propertiesAsArray","groupedData","Restructor","restructor"],"mappings":"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","file":"datarestructor-ie.js","sourceRoot":"../src/js","sourcesContent":["// https://gist.github.com/brianonn/4ef965a06b9e950d80e4e8b8e4c527f9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}","// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill\nif (!Array.prototype.filter){\n    Array.prototype.filter = function(func, thisArg) {\n      'use strict';\n      if ( ! ((typeof func === 'Function' || typeof func === 'function') && this) )\n          throw new TypeError();\n     \n      var len = this.length >>> 0,\n          res = new Array(len), // preallocate array\n          t = this, c = 0, i = -1;\n  \n      var kValue;\n      if (thisArg === undefined){\n        while (++i !== len){\n          // checks to see if the key was set\n          if (i in this){\n            kValue = t[i]; // in case t is changed in callback\n            if (func(t[i], i, t)){\n              res[c++] = kValue;\n            }\n          }\n        }\n      }\n      else{\n        while (++i !== len){\n          // checks to see if the key was set\n          if (i in this){\n            kValue = t[i];\n            if (func.call(thisArg, t[i], i, t)){\n              res[c++] = kValue;\n            }\n          }\n        }\n      }\n     \n      res.length = c; // shrink down array to proper size\n      return res;\n    };\n  }","//https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\nif (!Array.prototype.indexOf)  Array.prototype.indexOf = (function(Object, max, min){\n    \"use strict\";\n    return function indexOf(member, fromIndex) {\n      if(this===null||this===undefined)throw TypeError(\"Array.prototype.indexOf called on null or undefined\");\n      \n      var that = Object(this), Len = that.length >>> 0, i = min(fromIndex | 0, Len);\n      if (i < 0) i = max(0, Len+i); else if (i >= Len) return -1;\n      \n      if(member===void 0){ for(; i !== Len; ++i) if(that[i]===void 0 && i in that) return i; // undefined\n      }else if(member !== member){   for(; i !== Len; ++i) if(that[i] !== that[i]) return i; // NaN\n      }else                           for(; i !== Len; ++i) if(that[i] === member) return i; // all else\n  \n      return -1; // if the value was not found, then return -1\n    };\n  })(Object, Math.max, Math.min);","//http://tokenposts.blogspot.com/2012/04/javascript-objectkeys-browser.html\nif (!Object.keys) Object.keys = function(o) {\n    if (o !== Object(o))\n      throw new TypeError('Object.keys called on a non-object');\n    var k=[],p;\n    for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p);\n    return k;\n  }","\"use strict\";\n/**\n * @fileOverview Modded (compatibility, recursion depth) version of: https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss\n * @version ${project.version}\n * @see {@link https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objectss|stackoverflow flatten nested json objects}\n */\nvar module = module || {}; // Fallback for vanilla js without modules\n\n/**\n * internal_object_tools. Not meant to be used outside this repository.\n * @default {}\n */\nvar internal_object_tools = module.exports={}; // Export module for npm...\n\n/**\n * @typedef {Object} NameValuePair\n * @property {string} name - point separated names of the flattened main and sub properties, e.g. \"responses[2].hits.hits[4]._source.name\".\n * @property {string} value - value of the property\n */\n\n/**\n * @param {object} data hierarchical object that may consist fo fields, subfields and arrays.\n * @param {number} maxRecursionDepth\n * @returns {NameValuePair[]} array of property name and value pairs\n */\ninternal_object_tools.flattenToArray = function (data, maxRecursionDepth) {\n  var result = [];\n  if (typeof maxRecursionDepth !== \"number\" || maxRecursionDepth < 1) {\n    maxRecursionDepth = 20;\n  }\n  function recurse(cur, prop, depth) {\n    if (depth > maxRecursionDepth || typeof cur === \"function\") {\n      return;\n    }\n    if (Object(cur) !== cur) {\n      result.push({ name: prop, value: cur });\n    } else if (Array.isArray(cur)) {\n      var i;\n      var l = cur.length;\n      for (i = 0; i < l; i += 1) {\n        recurse(cur[i], prop + \"[\" + i + \"]\", depth + 1);\n      }\n      if (l === 0) {\n        result[prop] = [];\n        result.push({ name: prop, value: \"\" });\n      }\n    } else {\n      var isEmpty = true;\n      var p;\n      for (p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? prop + \".\" + p : p, depth + 1);\n      }\n      if (isEmpty && prop) {\n        result.push({ name: prop, value: \"\" });\n      }\n    }\n  }\n  recurse(data, \"\", 0);\n  return result;\n};\n","/**\n * @file Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = templateResolverInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction templateResolverInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Provides a simple template resolver, that replaces variables in double curly brackets with the values of a given object.\n * @module template_resolver\n */\nvar template_resolver = (module.exports = {}); // Export module for npm...\ntemplate_resolver.internalCreateIfNotExists = templateResolverInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\n\ntemplate_resolver.Resolver = (function () {\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Resolver. Is used inside this repository. It could also be used outside.\n   * @param {*} sourceDataObject The properties of this object will be used to replace the placeholders in the template.\n   * @constructs Resolver\n   * @alias module:template_resolver.Resolver\n   */\n  function Resolver(sourceDataObject) {\n    /**\n     * The properties of this source data object will be used to replace the placeholders in the template.\n     */\n    this.sourceDataObject = sourceDataObject;\n    /**\n     * Resolves the given template.\n     *\n     * The template may contain variables in double curly brackets.\n     * Supported variables are all properties of this object, e.g. \"{{fieldName}}\", \"{{displayName}}\", \"{{value}}\".\n     * Since this object may also contains (described) groups of sub objects, they can also be used, e.g. \"{{summaries[0].value}}\"\n     * Parts of the index can be inserted by using e.g. \"{{index[1]}}\".\n     *\n     * @param {string} template\n     * @returns {string} resolved template\n     */\n    this.resolveTemplate = function (template) {\n      return this.replaceResolvableFields(template, addFieldsPerGroup(this.resolvableFieldsOfAll(this.sourceDataObject)));\n    };\n    /**\n     * Returns a map like object, that contains all resolvable fields and their values as properties.\n     * This function takes a variable count of input parameters,\n     * each containing an object that contains resolvable fields to extract from.\n     *\n     * The recursion depth is limited to 3, so that an object,\n     * that contains an object can contain another object (but not further).\n     *\n     * Properties beginning with an underscore in their name will be filtered out, since they are considered as internal fields.\n     *\n     * @param {...object} varArgs variable count of parameters. Each parameter contains an object that fields should be resolvable for variables.\n     * @returns {object} object with resolvable field names and their values.\n     * @public\n     */\n    this.resolvableFieldsOfAll = function () {\n      var map = {};\n      var ignoreInternalFields = function (propertyName) {\n        return propertyName.indexOf(\"_\") !== 0 && propertyName.indexOf(\"._\") < 0;\n      };\n      var index;\n      for (index = 0; index < arguments.length; index += 1) {\n        addToFilteredMapObject(internal_object_tools.flattenToArray(arguments[index], 3), map, ignoreInternalFields);\n      }\n      return map;\n    };\n    /**\n     * Replaces all variables in double curly brackets, e.g. {{property}},\n     * with the value of that property from the resolvableProperties.\n     *\n     * Supported property types: string, number, boolean\n     * @param {string} stringContainingVariables\n     * @param {object[]} resolvableFields (name=value)\n     */\n    this.replaceResolvableFields = function (stringContainingVariables, resolvableFields) {\n      var replaced = stringContainingVariables;\n      var propertyNames = Object.keys(resolvableFields);\n      var propertyIndex = 0;\n      var propertyName = \"\";\n      var propertyValue = \"\";\n      for (propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex += 1) {\n        propertyName = propertyNames[propertyIndex];\n        propertyValue = resolvableFields[propertyName];\n        replaced = replaced.replace(\"{{\" + propertyName + \"}}\", propertyValue);\n      }\n      return replaced;\n    };\n  }\n\n  /**\n   * Adds the value of the \"fieldName\" property (including its group prefix) and its associated \"value\" property content.\n   * For example: detail[2].fieldName=\"name\", detail[2].value=\"Smith\" lead to the additional property detail.name=\"Smith\".\n   * @param {object} object with resolvable field names and their values.\n   * @returns {object} object with resolvable field names and their values.\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addFieldsPerGroup(map) {\n    var propertyNames = Object.keys(map);\n    var i, fullPropertyName, propertyInfo, propertyValue;\n    for (i = 0; i < propertyNames.length; i += 1) {\n      fullPropertyName = propertyNames[i];\n      propertyValue = map[fullPropertyName];\n      propertyInfo = getPropertyNameInfos(fullPropertyName);\n      // Supports fields that are defined by a property named \"fieldName\" (containing the name)\n      // and a property named \"value\" inside the same sub object (containing its value).\n      // Ignore custom fields that are named \"fieldName\"(propertyValue), since this would lead to an unpredictable behavior.\n      // TODO could make \"fieldName\" and \"value\" configurable\n      if (propertyInfo.name === \"fieldName\" && propertyValue !== \"fieldName\") {\n        map[propertyInfo.groupWithoutArrayIndices + propertyValue] = map[propertyInfo.group + \"value\"];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Infos about the full property name including the name of the group (followed by the separator) and the name of the property itself.\n   * @param {String} fullPropertyName\n   * @returns {Object} Contains \"group\" (empty or group name including trailing separator \".\"), \"groupWithoutArrayIndices\" and \"name\" (property name).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function getPropertyNameInfos(fullPropertyName) {\n    var positionOfRightMostSeparator = fullPropertyName.lastIndexOf(\".\");\n    var propertyName = fullPropertyName;\n    if (positionOfRightMostSeparator > 0) {\n      propertyName = fullPropertyName.substr(positionOfRightMostSeparator + 1);\n    }\n    var propertyGroup = \"\";\n    if (positionOfRightMostSeparator > 0) {\n      propertyGroup = fullPropertyName.substr(0, positionOfRightMostSeparator + 1); //includes the trailing \".\".\n    }\n    var propertyGroupWithoutArrayIndices = propertyGroup.replace(removeArrayBracketsRegEx, \"\");\n    return { group: propertyGroup, groupWithoutArrayIndices: propertyGroupWithoutArrayIndices, name: propertyName };\n  }\n\n  /**\n   * Collects all flattened name-value-pairs into one object using the property names as keys and their values as values (map-like).\n   * Example: `{name: \"accountNumber\", value: \"12345\"}` becomes `mapObject[\"accountNumber\"]=\"12345\"`.\n   *\n   * @param {NameValuePair[]} elements flattened array of name-value-pairs\n   * @param {object} mapObject container to collect the results. Needs to be created before e.g. using `{}`.\n   * @param {function} filterMatchesFunction takes the property name as string argument and returns true (include) or false (exclude).\n   * @protected\n   * @memberof module:template_resolver.Resolver\n   */\n  function addToFilteredMapObject(elements, mapObject, filterMatchesFunction) {\n    var index, element;\n    for (index = 0; index < elements.length; index += 1) {\n      element = elements[index];\n      if (typeof filterMatchesFunction === \"function\" && filterMatchesFunction(element.name)) {\n        mapObject[element.name] = element.value;\n      }\n    }\n    return mapObject;\n  }\n\n  return Resolver;\n}());\n","/**\n * @file Describes a data field of the restructured data.\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n * @version ${project.version}\n */\n\"use strict\";\nvar module = describedFieldInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction describedFieldInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * Describes a data field of the restructured data.\n * @module described_field\n */\nvar described_field = (module.exports = {}); // Export module for npm...\ndescribed_field.internalCreateIfNotExists = describedFieldInternalCreateIfNotExists;\n\n/**\n * Describes a field of the restructured data.\n * Dynamically added properties represent custom named groups containing DescribedDataField-Arrays.\n *\n * @typedef {Object} module:described_field.DescribedDataField\n * @property {string} [category=\"\"] - name of the category. Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [type=\"\"] - type of the data element. Examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as data filters.\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the splitted index. Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4]\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {string} displayName - display name of the field\n * @property {string} fieldName - field name\n * @property {{*}} value - content of the field\n * @property {module:described_field.DescribedDataField[]} [couldBeAnyCustomGroupName] any number of groups attached to the field each containing multiple fields\n */\n\ndescribed_field.DescribedDataFieldBuilder = (function () {\n  /**\n   * Builds a {@link module:described_field.DescribedDataField}.\n   * DescribedDataField is the main element of the restructured data and therefore considered \"public\".\n   * @constructs DescribedDataFieldBuilder\n   * @alias module:described_field.DescribedDataFieldBuilder\n   */\n  function DescribedDataFieldBuilder() {\n    /**\n     * @type {module:described_field.DescribedDataField}\n     */\n    this.describedField = {\n      category: \"\",\n      type: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      index: [],\n      groupNames: [],\n      displayName: \"\",\n      fieldName: \"\",\n      value: \"\"\n    };\n    /**\n     * Takes over all values of the template {@link module:described_field.DescribedDataField}.\n     * @function\n     * @param {module:described_field.DescribedDataField} template\n     * @returns {DescribedDataFieldBuilder}\n     * @example fromDescribedDataField(sourceField)\n     */\n    this.fromDescribedDataField = function (template) {\n      this.category(template.category);\n      this.type(template.type);\n      this.abbreviation(template.abbreviation);\n      this.image(template.image);\n      this.index(template.index);\n      this.groupNames(template.groupNames);\n      this.displayName(template.displayName);\n      this.fieldName(template.fieldName);\n      this.value(template.value);\n      return this;\n    };\n    /**\n     * Sets the category.\n     *\n     * Contains a short domain nam, for example:\n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example category(\"Product\")\n     */\n    this.category = function (value) {\n      this.describedField.category = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the type.\n     *\n     * Contains the type of the entry, for example:\n     * - \"summary\" for e.g. a list overview.\n     * - \"detail\" e.g. when a summary is selected.\n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example type(\"summary\")\n     */\n    this.type = function (value) {\n      this.describedField.type = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     *\n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example abbreviation(\"P\")\n     */\n    this.abbreviation = function (value) {\n      this.describedField.abbreviation = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example image(\"img/product.png\")\n     */\n    this.image = function (value) {\n      this.describedField.image = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the index as an array of numbers containing the splitted array indexes of the source field.\n     * Example: \"responses[2].hits.hits[4]._source.name\" will have an index of [2,4].\n     *\n     * @function\n     * @param {number[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example index([2,4])\n     */\n    this.index = function (value) {\n      this.describedField.index = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the group names as an array of strings containing the names of the dynamically added properties,\n     * that contain an array of {@link module:described_field.DescribedDataField}-Objects.\n     *\n     * @function\n     * @param {string[]} [value=[]]\n     * @returns {DescribedDataFieldBuilder}\n     * @example groupNames([\"summaries\",\"details\",\"options\"])\n     */\n    this.groupNames = function (value) {\n      this.describedField.groupNames = withDefaultArray(value, []);\n      return this;\n    };\n    /**\n     * Sets the display name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example displayName(\"Color\")\n     */\n    this.displayName = function (value) {\n      this.describedField.displayName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the (technical) field name.\n     *\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {DescribedDataFieldBuilder}\n     * @example fieldName(\"color\")\n     */\n    this.fieldName = function (value) {\n      this.describedField.fieldName = withDefaultString(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the value/content of the field.\n     *\n     * @function\n     * @param {*} value\n     * @returns {DescribedDataFieldBuilder}\n     * @example value(\"darkblue\")\n     */\n    this.value = function (value) {\n      this.describedField.value = value;\n      return this;\n    };\n\n    /**\n     * Finalizes the settings and builds the {@link module:described_field.DescribedDataField}.\n     * @function\n     * @returns {module:described_field.DescribedDataField}\n     */\n    this.build = function () {\n      return this.describedField;\n    };\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value !== null && value !== \"\";\n  }\n\n  function withDefaultString(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function withDefaultArray(value, defaultValue) {\n    return value === undefined || value === null ? defaultValue : value;\n  }\n\n  return DescribedDataFieldBuilder;\n}());\n\n/**\n * Creates a new described data field with all properties of the original one except for dynamically added groups.\n * @param {module:described_field.DescribedDataField} describedDataField\n * @returns {module:described_field.DescribedDataField}\n * @memberof module:described_field\n */\ndescribed_field.copyWithoutGroups = function (describedDataField) {\n  return new described_field.DescribedDataFieldBuilder().fromDescribedDataField(describedDataField).groupNames([]).build();\n};\n\ndescribed_field.DescribedDataFieldGroup = (function () {\n  /**\n   * Adds groups to {@link module:described_field.DescribedDataField}s. These groups are dynamically added properties\n   * that contain an array of sub fields of the same type {@link module:described_field.DescribedDataField}s.\n   *\n   * @param {module:described_field.DescribedDataField} dataField\n   * @constructs DescribedDataFieldGroup\n   * @alias module:described_field.DescribedDataFieldGroup\n   * @example new described_field.DescribedDataFieldGroup(field).addGroupEntry(\"details\", detailField);\n   */\n  function DescribedDataFieldGroup(dataField) {\n    this.dataField = dataField;\n\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entry will be added\n     * @param {module:described_field.DescribedDataField} describedField sub field that is added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n    this.addGroupEntry = function (groupName, describedField) {\n      this.addGroupEntries(groupName, [describedField]);\n      return this;\n    };\n\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @function\n     * @param {String} groupName name of the group to which the entries will be added\n     * @param {module:described_field.DescribedDataField[]} describedFields sub fields that are added to the group\n     * @returns {DescribedDataFieldGroup}\n     */\n    this.addGroupEntries = function (groupName, describedFields) {\n      if (!groupName || groupName.length === 0) {\n        return this;\n      }\n      if (!describedFields || describedFields.length === 0) {\n        return this;\n      }\n      if (this.dataField[groupName] === undefined) {\n        this.dataField.groupNames.push(groupName);\n        this.dataField[groupName] = [];\n      }\n      var index;\n      var describedField;\n      for (index = 0; index < describedFields.length; index += 1) {\n        describedField = describedFields[index];\n        this.dataField[groupName].push(describedField);\n      }\n      return this;\n    };\n  }\n\n  return DescribedDataFieldGroup;\n}());\n","/**\n * @file datarestructor transforms parsed JSON objects into a uniform data structure\n * @version {@link https://github.com/JohT/data-restructor-js/releases/latest latest version}\n * @author JohT\n */\n\n \"use strict\";\nvar module = datarestructorInternalCreateIfNotExists(module); // Fallback for vanilla js without modules\n\nfunction datarestructorInternalCreateIfNotExists(objectToCheck) {\n  return objectToCheck || {};\n}\n\n/**\n * datarestructor namespace and module declaration.\n * It contains all functions to convert an object (e.g. parsed JSON) into uniform enumerated list of described field entries.\n * \n * <b>Transformation steps:</b>\n * - JSON\n * - flatten\n * - mark and identify\n * - add array fields\n * - deduplicate \n * - group\n * - flatten again\n * @module datarestructor\n */\nvar datarestructor = module.exports={}; // Export module for npm...\ndatarestructor.internalCreateIfNotExists = datarestructorInternalCreateIfNotExists;\n\nvar internal_object_tools = internal_object_tools || require(\"../../lib/js/flattenToArray\"); // supports vanilla js & npm\nvar template_resolver = template_resolver || require(\"../../src/js/templateResolver\"); // supports vanilla js & npm\nvar described_field = described_field || require(\"../../src/js/describedfield\"); // supports vanilla js & npm\n\n/**\n * Takes the full qualified original property name and extracts a simple name out of it.\n * \n * @callback module:datarestructor.propertyNameFunction\n * @param {string} propertyName full qualified, point separated property name \n * @return {String} extracted, simple name\n */\n\n/**\n * Describes a selected part of the incoming data structure and defines, \n * how the data should be transformed.\n * \n * @typedef {Object} module:datarestructor.PropertyStructureDescription\n * @property {string} type - \"\"(default). Some examples: \"summary\" for e.g. a list overview. \"detail\" e.g. when a summary is selected. \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n * @property {string} category - name of the category. Default = \"\". Could contain a short domain name like \"product\" or \"vendor\".\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {boolean} propertyPatternTemplateMode - \"false\"(default): property name needs to be equal to the pattern. \"true\" allows variables like \"{{fieldName}}\" inside the pattern.\n * @property {string} propertyPattern - property name pattern (without array indices) to match\n * @property {string} indexStartsWith - \"\"(default) matches all ids. String that needs to match the beginning of the id. E.g. \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n * @property {module:datarestructor.propertyNameFunction} getDisplayNameForPropertyName - display name for the property. \"\"(default) last property name element with upper case first letter.\n * @property {module:datarestructor.propertyNameFunction} getFieldNameForPropertyName - field name for the property. \"\" (default) last property name element.\n * @property {string} groupName - name of the property, that contains grouped entries. Default=\"group\".\n * @property {string} groupPattern - Pattern that describes how to group entries. \"groupName\" defines the name of this group. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationPattern - Pattern that describes where the group should be moved to. Default=\"\"=Group will not be moved. A pattern may contain variables in double curly brackets {{variable}}.\n * @property {string} groupDestinationName - (default=groupName) Name of the group when it had been moved to the destination.\n * @property {string} deduplicationPattern - Pattern to use to remove duplicate entries. A pattern may contain variables in double curly brackets {{variable}}.\n */\n\ndatarestructor.PropertyStructureDescriptionBuilder = (function () {\n  \"use strict\";\n\n  /**\n   * Builder for a {@link PropertyStructureDescription}.\n   * @constructs PropertyStructureDescriptionBuilder\n   * @alias module:datarestructor.PropertyStructureDescriptionBuilder\n   */\n  function PropertyStructureDescription() {\n    /**\n     * @type {module:datarestructor.PropertyStructureDescription}\n     */\n    this.description = {\n      type: \"\",\n      category: \"\",\n      abbreviation: \"\",\n      image: \"\",\n      propertyPatternTemplateMode: false,\n      propertyPattern: \"\",\n      indexStartsWith: \"\",\n      groupName: \"group\",\n      groupPattern: \"\",\n      groupDestinationPattern: \"\",\n      groupDestinationName: null,\n      deduplicationPattern: \"\",\n      getDisplayNameForPropertyName: null,\n      getFieldNameForPropertyName: null,\n      matchesPropertyName: null\n    };\n    /**\n     * Sets the type.\n     * \n     * Contains the type of the entry, for example: \n     * - \"summary\" for e.g. a list overview. \n     * - \"detail\" e.g. when a summary is selected. \n     * - \"filter\" e.g. for field/value pair results that can be selected as search parameters.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example type(\"summary\")\n     */\n    this.type = function (value) {\n      this.description.type = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the category.\n     * \n     * Contains a short domain nam, for example: \n     * - \"product\" for products\n     * - \"vendor\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example category(\"Product\")\n     */\n    this.category = function (value) {\n      this.description.category = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional abbreviation.\n     * \n     * Contains a symbol character or a very short abbreviation of the category.\n     * - \"P\" for products\n     * - \"V\" for vendors\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example abbreviation(\"P\")\n     */\n    this.abbreviation = function (value) {\n      this.description.abbreviation = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional path to an image resource.\n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example image(\"img/product.png\")\n     */\n    this.image = function (value) {\n      this.description.image = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets \"equal mode\" for the property pattern.\n     * \n     * \"propertyPattern\" need to match exactly if this mode is activated.\n     *  It clears propertyPatternTemplateMode which means \"equal\" mode.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.propertyPatternEqualMode = function () {\n      this.description.propertyPatternTemplateMode = false;\n      return this;\n    };\n    /**\n     * Sets \"template mode\" for the property pattern.\n     * \n     * \"propertyPattern\" can contain variables like {{fieldName}} and\n     * doesn't need to match the property name exactly. If the \"propertyPattern\"\n     * is shorter than the property name, it also matches when the property name\n     * starts with the \"propertyPattern\".\n     * \n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.propertyPatternTemplateMode = function () {\n      this.description.propertyPatternTemplateMode = true;\n      return this;\n    };\n    /**\n     * Sets the property name pattern. \n     * \n     * Contains single property names with sub types separated by \".\" without array indices.\n     * May contain variables in double curly brackets.\n     * \n     * Example: \n     * - responses.hits.hits._source.{{fieldName}}\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example propertyPattern(\"responses.hits.hits._source.{{fieldName}}\")\n     */\n    this.propertyPattern = function (value) {\n      this.description.propertyPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the optional beginning of the id that needs to match.\n     * Matches all indices if set to \"\" (or not called).\n     * \n     * For example:\n     * - \"1.\" will match id=\"1.3.4\" but not \"0.1.2\".\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example indexStartsWith(\"1.\")\n     */\n    this.indexStartsWith = function (value) {\n      this.description.indexStartsWith = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Overrides the display name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name starting with an upper case character.\n     *  \n     * For example:\n     * - \"Product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example displayPropertyName(\"Product\")\n     */\n    this.displayPropertyName = function (value) {\n      this.description.getDisplayNameForPropertyName = createNameExtractFunction(value, this.description);\n      if (isSpecifiedString(value)) {\n        return this;\n      }\n      this.description.getDisplayNameForPropertyName = removeArrayValuePropertyPostfixFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      this.description.getDisplayNameForPropertyName = upperCaseFirstLetterForFunction(\n        this.description.getDisplayNameForPropertyName\n      );\n      return this;\n    };\n    /**\n     * Overrides the (technical) field name of the property.\n     * \n     * If it is not set or set to \"\" then it will be derived from the\n     * last part of original property name.\n     *  \n     * For example:\n     * - \"product\"\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example fieldName(\"product\")\n     */\n    this.fieldName = function (value) {\n      this.description.getFieldNameForPropertyName = createNameExtractFunction(value, this.description);\n      return this;\n    };\n    /**\n     * Sets the name of the property, that contains grouped entries. \n     * \n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupName(\"details\")\n     */\n    this.groupName = function (value) {\n      this.description.groupName = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes how to group entries. \n     * \n     * \"groupName\" defines the name of this group.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupPattern(\"{{type}}-{{category}}\")\n     */\n    this.groupPattern = function (value) {\n      this.description.groupPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the pattern that describes where the group should be moved to. \n     * \n     * Default=\"\"=Group will not be moved.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"main-{{category}}\")\n     */\n    this.groupDestinationPattern = function (value) {\n      this.description.groupDestinationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Sets the name of the group when it had been moved to the destination.\n     * \n     * The default value is the groupName, which will be used when the value is not valid (null or empty)\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example groupDestinationPattern(\"options\")\n     */\n    this.groupDestinationName = function (value) {\n      this.description.groupDestinationName = withDefault(value, this.description.groupName);\n      return this;\n    };\n    /**\n     * Sets the pattern to be used to remove duplicate entries. \n     * \n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * A pattern may contain variables in double curly brackets {{variable}}.\n     * @function\n     * @param {String} [value=\"\"]\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     * @example deduplicationPattern(\"{{category}}--{{type}}--{{index[0]}}--{{index[1]}}--{{fieldName}}\")\n     */\n    this.deduplicationPattern = function (value) {\n      this.description.deduplicationPattern = withDefault(value, \"\");\n      return this;\n    };\n    /**\n     * Finalizes the settings and builds the  PropertyStructureDescription.\n     * @function\n     * @returns {module:datarestructor.PropertyStructureDescription}\n     */\n    this.build = function () {\n      this.description.matchesPropertyName = createFunctionMatchesPropertyName(this.description);\n      if (this.description.getDisplayNameForPropertyName == null) {\n        this.displayPropertyName(\"\");\n      }\n      if (this.description.getFieldNameForPropertyName == null) {\n        this.fieldName(\"\");\n      }\n      if (this.description.groupDestinationName == null) {\n        this.groupDestinationName(\"\");\n      }\n      return this.description;\n    };\n  }\n\n  function createNameExtractFunction(value, description) {\n    if (isSpecifiedString(value)) {\n      return function () {\n        return value;\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      var patternToMatch = description.propertyPattern; // closure (closed over) parameter\n      return extractNameUsingTemplatePattern(patternToMatch);\n    }\n    return extractNameUsingRightMostPropertyNameElement();\n  }\n\n  function createFunctionMatchesPropertyName(description) {\n    var propertyPatternToMatch = description.propertyPattern; // closure (closed over) parameter\n    if (!isSpecifiedString(propertyPatternToMatch)) {\n      return function () {\n        return false; // Without a propertyPattern, no property will match (deactivated mark/identify).\n      };\n    }\n    if (description.propertyPatternTemplateMode) {\n      return function (propertyNameWithoutArrayIndices) {\n        return templateModePatternRegexForPattern(propertyPatternToMatch).exec(propertyNameWithoutArrayIndices) != null;\n      };\n    }\n    return function (propertyNameWithoutArrayIndices) {\n      return propertyNameWithoutArrayIndices === propertyPatternToMatch;\n    };\n  }\n\n  function rightMostPropertyNameElement(propertyName) {\n    var regularExpression = new RegExp(\"(\\\\w+)$\", \"gi\");\n    var match = propertyName.match(regularExpression);\n    if (match != null) {\n      return match[0];\n    }\n    return propertyName;\n  }\n\n  function upperCaseFirstLetter(value) {\n    if (value.length > 1) {\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    }\n    return value;\n  }\n\n  function upperCaseFirstLetterForFunction(nameExtractFunction) {\n    return function (propertyName) {\n      return upperCaseFirstLetter(nameExtractFunction(propertyName));\n    };\n  }\n\n  function removeArrayValuePropertyPostfixFunction(nameExtractFunction) {\n    return function (propertyName) {\n      var name = nameExtractFunction(propertyName);\n      name = name != null ? name : \"\";\n      return name.replace(\"_comma_separated_values\", \"\");\n    };\n  }\n\n  function extractNameUsingTemplatePattern(propertyPattern) {\n    return function (propertyName) {\n      var regex = templateModePatternRegexForPatternAndVariable(propertyPattern, \"{{fieldName}}\");\n      var match = regex.exec(propertyName);\n      if (match && match[1] != \"\") {\n        return match[1];\n      }\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function extractNameUsingRightMostPropertyNameElement() {\n    return function (propertyName) {\n      return rightMostPropertyNameElement(propertyName);\n    };\n  }\n\n  function templateModePatternRegexForPattern(propertyPatternToUse) {\n    var placeholderInDoubleCurlyBracketsRegEx = new RegExp(\"\\\\\\\\\\\\{\\\\\\\\\\\\{[-\\\\w]+\\\\\\\\\\\\}\\\\\\\\\\\\}\", \"gi\");\n    return templateModePatternRegexForPatternAndVariable(propertyPatternToUse, placeholderInDoubleCurlyBracketsRegEx);\n  }\n\n  function templateModePatternRegexForPatternAndVariable(propertyPatternToUse, variablePattern) {\n    var pattern = escapeCharsForRegEx(propertyPatternToUse);\n    if (typeof variablePattern === \"string\") {\n      variablePattern = escapeCharsForRegEx(variablePattern);\n    }\n    pattern = pattern.replace(variablePattern, \"([-\\\\w]+)\");\n    pattern = \"^\" + pattern;\n    return new RegExp(pattern, \"i\");\n  }\n\n  function escapeCharsForRegEx(characters) {\n    var nonWordCharactersRegEx = new RegExp(\"([^-\\\\w])\", \"gi\");\n    return characters.replace(nonWordCharactersRegEx, \"\\\\$1\");\n  }\n\n  function withDefault(value, defaultValue) {\n    return isSpecifiedString(value) ? value : defaultValue;\n  }\n\n  function isSpecifiedString(value) {\n    return typeof value === \"string\" && value != null && value != \"\";\n  }\n\n  return PropertyStructureDescription;\n})();\n\n/**\n * Adds a group item/entry to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntryFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n */\n\n/**\n * Adds some group items/entries to the {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.addGroupEntriesFunction\n * @param {String} groupName name of the group that should be added\n * @param {module:datarestructor.DescribedEntry[]} describedEntry entries that should be added to the group\n */\n\n/**\n * @typedef {Object} module:datarestructor.DescribedEntry\n * @property {string} category - category of the result from the PropertyStructureDescription using a short name or e.g. a symbol character\n * @property {string} type - type of the result from PropertyStructureDescription\n * @property {string} [abbreviation=\"\"] - one optional character, a symbol character or a short abbreviation of the category\n * @property {string} [image=\"\"] - one optional path to an image resource\n * @property {string} index - array of numbers containing the split index. Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with the two elements: [2,4]\n * @property {string} displayName - display name extracted from the point separated hierarchical property name, e.g. \"Name\"\n * @property {string} fieldName - field name extracted from the point separated hierarchical property name, e.g. \"name\"\n * @property {string} value - content of the field\n * @property {string[]} groupNames - array of names of all dynamically added properties representing groups\n * @property {module:datarestructor.addGroupEntryFunction} addGroupEntry - function, that adds an entry to the given group. If the group does not exist, it will be created.\n * @property {module:datarestructor.addGroupEntriesFunction} addGroupEntries - function, that adds entries to the given group. If the group does not exist, it will be created.\n * @property {boolean} _isMatchingIndex - true, when _identifier.index matches the described \"indexStartsWith\"\n * @property {Object} _identifier - internal structure for identifier. Avoid using it outside since it may change.\n * @property {string} _identifier.index - array indices in hierarchical order separated by points, e.g. \"0.0\"\n * @property {string} _identifier.value - the (single) value of the \"flattened\" property, e.g. \"Smith\"\n * @property {string} _identifier.propertyNameWithArrayIndices - the \"original\" flattened property name in hierarchical order separated by points, e.g. \"responses[0].hits.hits[0]._source.name\"\n * @property {string} _identifier.propertyNameWithoutArrayIndices - same as propertyNamesWithArrayIndices but without array indices, e.g. \"responses.hits.hits._source.name\"\n * @property {string} _identifier.groupId - Contains the resolved groupPattern from the PropertyStructureDescription. Entries with the same id will be grouped into the \"groupName\" of the PropertyStructureDescription.\n * @property {string} _identifier.groupDestinationId - Contains the resolved groupDestinationPattern from the PropertyStructureDescription. Entries with this id will be moved to the given destination group.\n * @property {string} _identifier.deduplicationId - Contains the resolved deduplicationPattern from the PropertyStructureDescription. Entries with the same id will be considered to be a duplicate and hence removed.\n * @property {Object} _description - PropertyStructureDescription for internal use. Avoid using it outside since it may change.\n */\n\n/**\n * Returns a field value of the given {@link module:datarestructor.DescribedEntry}.\n * \n * @callback module:datarestructor.stringFieldOfDescribedEntryFunction\n * @param {module:datarestructor.DescribedEntry} entry described entry that contains the field that should be returned\n * @returns {String} field value \n */\n\ndatarestructor.DescribedEntryCreator = (function () {\n  \"use strict\";\n\n  var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n\n  /**\n   * Creates a {@link module:datarestructor.DescribedEntry}.\n   * @constructs DescribedEntryCreator\n   * @alias module:datarestructor.DescribedEntryCreator\n   */\n  function DescribedEntry(entry, description) {\n    var indices = indicesOf(entry.name);\n    var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n    var templateResolver = new template_resolver.Resolver(this);\n    this.category = description.category;\n    this.type = description.type;\n    this.abbreviation = description.abbreviation;\n    this.image = description.image;\n    /**\n     * Array of numbers containing the split index.\n     * Example: \"responses[2].hits.hits[4]._source.name\" leads to an array with two elements: [2,4]\n     * This is the public version of the internal variable _identifier.index, which contains in contrast all index elements in one point separated string (e.g. \"2.4\").\n     * @type {number[]}\n     */\n    this.index = indices.numberArray;\n    this.displayName = description.getDisplayNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.fieldName = description.getFieldNameForPropertyName(propertyNameWithoutArrayIndices);\n    this.value = entry.value;\n    this.groupNames = [];\n    this._isMatchingIndex = indices.pointDelimited.indexOf(description.indexStartsWith) == 0;\n    this._description = description;\n\n    this._identifier = {\n      index: indices.pointDelimited,\n      propertyNameWithArrayIndices: entry.name,\n      propertyNameWithoutArrayIndices: propertyNameWithoutArrayIndices,\n      groupId: \"\",\n      groupDestinationId: \"\",\n      deduplicationId: \"\"\n    };\n    this._identifier.groupId = templateResolver.replaceResolvableFields(\n      description.groupPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.groupDestinationId = templateResolver.replaceResolvableFields(\n      description.groupDestinationPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n    this._identifier.deduplicationId = templateResolver.replaceResolvableFields(\n      description.deduplicationPattern,\n      templateResolver.resolvableFieldsOfAll(this, this._description, this._identifier)\n    );\n\n    /**\n     * Adds an entry to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName name of the group that should be added\n     * @param {module:datarestructor.DescribedEntry} describedEntry entry that should be added to the group\n     */\n    this.addGroupEntry = function(groupName, describedEntry) {\n      this.addGroupEntries(groupName, [describedEntry]);\n    };\n\n    /**\n     * Adds entries to the given group. If the group does not exist, it will be created.\n     * @param {String} groupName\n     * @param {module:datarestructor.DescribedEntry[]} describedEntries\n     */\n    this.addGroupEntries = function(groupName, describedEntries) {\n      if (!this[groupName]) {\n        this.groupNames.push(groupName);\n        this[groupName] = [];\n      }\n      var index;\n      var describedEntry;\n      for (index = 0; index < describedEntries.length; index += 1) {\n        describedEntry = describedEntries[index];\n        this[groupName].push(describedEntry);\n      }\n    };\n  }\n  /**\n   * @typedef {Object} module:datarestructor.ExtractedIndices\n   * @property {string} pointDelimited - bracket indices separated by points\n   * @property {number[]} numberArray as array of numbers\n   */\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {String} fullPropertyName\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n  function indicesOf(fullPropertyName) {\n    var arrayBracketsRegEx = new RegExp(\"\\\\[(\\\\d+)\\\\]\", \"gi\");\n    return indicesOfWithRegex(fullPropertyName, arrayBracketsRegEx);\n  }\n\n  /**\n   * Returns \"1.12.123\" and [1,12,123] for \"results[1].hits.hits[12].aggregates[123]\".\n   *\n   * @param {string} fullPropertyName\n   * @param {RegExp} regexWithOneNumberGroup\n   * @return {module:datarestructor.ExtractedIndices} extracted indices in different representations\n   * @protected\n   * @memberof module:datarestructor.DescribedEntryCreator\n   */\n  function indicesOfWithRegex(fullPropertyName, regexWithOneNumberGroup) {\n    var pointDelimited = \"\";\n    var numberArray = [];\n    var match;\n    do {\n      match = regexWithOneNumberGroup.exec(fullPropertyName);\n      if (match) {\n        if (pointDelimited.length > 0) {\n          pointDelimited += \".\";\n        }\n        pointDelimited += match[1];\n        numberArray.push(parseInt(match[1]));\n      }\n    } while (match);\n    return { pointDelimited: pointDelimited, numberArray: numberArray };\n  }\n\n  return DescribedEntry;\n})();\n\ndatarestructor.Transform = (function () {\n  \"use strict\";\n\n  /**\n   * Main class for the data transformation.\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions\n   * @constructs Transform\n   * @alias module:datarestructor.Transform\n   */\n  function Transform(descriptions) {\n    /**\n     * Descriptions of the input data that define the behaviour of the transformation.\n     * @type {module:datarestructor.DescribedEntry[]}\n     */\n    this.descriptions = descriptions;\n    /**\n     * Debug mode switch, that enables/disables detailed logging.\n     * @protected\n     * @type {boolean}\n     */\n    this.debugMode = false;\n    /**\n     * Enables debug mode. Logs additional information.\n     * @returns {module:datarestructor.Transform}\n     */\n    this.enableDebugMode = function () {\n      this.debugMode = true;\n      return this;\n    };\n    /**\n     * Maximum recursion depth. Defaults to 8, \n     * @protected \n     * @type {number}\n     */\n    this.maxRecursionDepth = 8;\n\n    /**\n     * Sets the maximum recursion depth. Defaults to 8 if not set.\n     * @param {number} value non negative number.\n     * @returns {module:datarestructor.Transform}\n     */\n    this.setMaxRecursionDepth = function (value) {\n      if ((typeof value !== \"number\") || (value < 0)) {\n        throw \"Invalid max recursion depth value: \" + value;\n      }\n      this.maxRecursionDepth = value;\n      return this;\n    };\n    /**\n     * \"Assembly line\", that takes the (pared JSON) data and processes it using all given descriptions in their given order.\n     * @param {object} data - parsed JSON data or any other data object\n     * @returns {module:datarestructor.DescribedEntry[]}\n     * @example\n     * var allDescriptions = [];\n     * allDescriptions.push(summariesDescription());\n     * allDescriptions.push(detailsDescription());\n     * var result = new datarestructor.Transform(allDescriptions).processJson(jsonData);\n     */\n    this.processJson = function (data) {\n      return processJsonUsingDescriptions(data, this.descriptions, this.debugMode, this.maxRecursionDepth);\n    };\n  }\n\n  /**\n   * \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n   * @param {object} jsonData - parsed JSON data or any other data object\n   * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n   * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n   * @param {number} maxRecursionDepth - maximum recursion depth. Defaults to 8 if not set.\n   * @returns {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function processJsonUsingDescriptions(jsonData, descriptions, debugMode, maxRecursionDepth) {\n    // \"Flatten\" the hierarchical input json to an array of property names (point separated \"folders\") and values.\n    var processedData = internal_object_tools.flattenToArray(jsonData);\n    // Fill in properties ending with the name \"_comma_separated_values\" for array values to make it easier to display them.\n    processedData = fillInArrayValues(processedData);\n\n    if (debugMode) {\n      console.log(\"flattened data with array values:\");\n      console.log(processedData);\n    }\n\n    // Mark, identify and harmonize the flattened data by applying one description after another in their given order.\n    var describedData = [];\n    var descriptionIndex, description, dataWithDescription;\n    for (descriptionIndex = 0; descriptionIndex < descriptions.length; descriptionIndex += 1) {\n      description = descriptions[descriptionIndex];\n      // Filter all entries that match the current description and enrich them with it\n      dataWithDescription = extractEntriesByDescription(processedData, description);\n      // Remove duplicate entries where a deduplicationPattern is described\n      describedData = deduplicateFlattenedData(describedData, dataWithDescription);\n    }\n    processedData = describedData;\n\n    if (debugMode) {\n      console.log(\"describedData data:\");\n      console.log(processedData);\n    }\n\n    // Group entries where a groupPattern is described\n    processedData = groupFlattenedData(processedData);\n\n    if (debugMode) {\n      console.log(\"grouped describedData data:\");\n      console.log(processedData);\n    }\n\n    // Move group entries where a groupDestinationPattern is described\n    processedData = applyGroupDestinationPattern(processedData);\n\n    if (debugMode) {\n      console.log(\"moved grouped describedData data:\");\n      console.log(processedData);\n    }\n\n    // Turns the grouped object back into an array of DescribedEntry-Objects\n    processedData = propertiesAsArray(processedData);\n\n    // Converts the internal described entries  into described fields\n    processedData = toDescribedFields(processedData, maxRecursionDepth);\n\n    if (debugMode) {\n      console.log(\"transformed result:\");\n      console.log(processedData);\n    }\n\n    return processedData;\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries that occur later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * The id is extracted from every element using the given function.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function mergeFlattenedData(entries, entriesToMerge, idOfElementFunction) {\n    var entriesToMergeById = asIdBasedObject(entriesToMerge, idOfElementFunction);\n    var merged = [];\n    var index, entry, id;\n    for (index = 0; index < entries.length; index += 1) {\n      entry = entries[index];\n      id = idOfElementFunction(entry);\n      if (id == null || id === \"\" || entriesToMergeById[id] == null) {\n        merged.push(entry);\n      }\n    }\n    for (index = 0; index < entriesToMerge.length; index += 1) {\n      entry = entriesToMerge[index];\n      merged.push(entry);\n    }\n    return merged;\n  }\n\n  /**\n   * Takes two arrays of objects, e.g. [{id: B, value: 2},{id: C, value: 3}]\n   * and [{id: A, value: 1},{id: B, value: 4}] and merges them into one:\n   * [{id: C, value: 3},{id: A, value: 1},{id: B, value: 4}]\n   *\n   * Entries with the same id (\"duplicates\") will be overwritten.\n   * Only the last element with the same id remains. The order is\n   * determined by the order of the array elements, whereas the first\n   * array comes before the second one. This means, that entries with the\n   * same id in the second array overwrite entries in the first array,\n   * and entries occurring later in the array overwrite earlier ones,\n   * if they have the same id.\n   *\n   * \"entriesToMerge\" will be returned directly, if \"entries\" is null or empty.\n   *\n   * The id is extracted from every element using their deduplication pattern (if available).\n   *\n   * @param {module:datarestructor.DescribedEntry[]} entries\n   * @param {module:datarestructor.DescribedEntry[]} entriesToMerge\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @see mergeFlattenedData\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function deduplicateFlattenedData(entries, entriesToMerge) {\n    if (entries == null || entries.length == 0) {\n      return entriesToMerge;\n    }\n    var idOfElementFunction = function (entry) {\n      return entry._identifier.deduplicationId;\n    };\n    return mergeFlattenedData(entries, entriesToMerge, idOfElementFunction);\n  }\n\n  /**\n   * Converts the given elements to an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1.\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} idOfElementFunction returns the id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function asIdBasedObject(elements, idOfElementFunction) {\n    var idIndexedObject = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      idIndexedObject[idOfElementFunction(element)] = element;\n    }\n    return idIndexedObject;\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id (determined by the entry's groupPattern).\n   * For example, [{id: A, value: 1}] becomes result['A'] = 1.\n   *\n   * Furthermore, this function creates a group property (determined by the entry's groupName)\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function groupFlattenedData(flattenedData) {\n    return groupById(\n      flattenedData,\n      function (entry) {\n        return entry._identifier.groupId;\n      },\n      function (entry) {\n        return entry._description.groupName;\n      }\n    );\n  }\n\n  /**\n   * Converts the given elements into an object, that provides these\n   * entries by their id. For example, [{id: A, value: 1}] becomes\n   * result['A'] = 1. Furthermore, this function creates a group property (with the name )\n   * and collects all related elements (specified by their group pattern) in it.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} elements of DescribedEntry elements\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupNameOfElementFunction function, that returns the name of the group property that will be created inside the \"main\" element.\n   * @param {module:datarestructor.stringFieldOfDescribedEntryFunction} groupIdOfElementFunction returns the group id of an DescribedEntry\n   * @return {module:datarestructor.DescribedEntry[] entries indexed by id\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function groupById(elements, groupIdOfElementFunction, groupNameOfElementFunction) {\n    var groupedResult = new Object();\n    for (var index = 0; index < elements.length; index++) {\n      var element = elements[index];\n      var groupId = groupIdOfElementFunction(element);\n      if (groupId === \"\") {\n        continue;\n      }\n      var groupName = groupNameOfElementFunction(element);\n      if (groupName == null || groupName === \"\") {\n        continue;\n      }\n      if (!groupedResult[groupId]) {\n        groupedResult[groupId] = element;\n      }\n      groupedResult[groupId].addGroupEntry(groupName, element);\n    }\n    return groupedResult;\n  }\n\n  /**\n   * Extracts entries out of \"flattened\" JSON data and provides an array of objects.\n   * @param {Object[]} flattenedData - flattened json from search query result\n   * @param {string} flattenedData[].name - name of the property in hierarchical order separated by points\n   * @param {string} flattenedData[].value - value of the property as string\n   * @param {module:datarestructor.PropertyStructureDescription} - description of structure of the entries that should be extracted\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function extractEntriesByDescription(flattenedData, description) {\n    var removeArrayBracketsRegEx = new RegExp(\"\\\\[\\\\d+\\\\]\", \"gi\");\n    var filtered = [];\n\n    flattenedData.filter(function (entry) {\n      var propertyNameWithoutArrayIndices = entry.name.replace(removeArrayBracketsRegEx, \"\");\n      if (description.matchesPropertyName(propertyNameWithoutArrayIndices)) {\n        var describedEntry = new datarestructor.DescribedEntryCreator(entry, description);\n        if (describedEntry._isMatchingIndex) {\n          filtered.push(describedEntry);\n        }\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * Takes already grouped {@link module:datarestructor.DescribedEntry} objects and\n   * uses their \"_identifier.groupDestinationId\" (if exists)\n   * to move groups to the given destination.\n   *\n   * This is useful, if separately described groups like \"summary\" and \"detail\" should be put together,\n   * so that every summery contains a group with the regarding details.\n   *\n   * @param {module:datarestructor.DescribedEntry[]} groupedObject - already grouped entries\n   * @return {module:datarestructor.DescribedEntry[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function applyGroupDestinationPattern(groupedObject) {\n    var keys = Object.keys(groupedObject);\n    var keysToDelete = [];\n    for (var index = 0; index < keys.length; index++) {\n      var key = keys[index];\n      var entry = groupedObject[key];\n      if (entry._description.groupDestinationPattern != \"\") {\n        var destinationKey = entry._identifier.groupDestinationId;\n        if (groupedObject[destinationKey] != null) {\n          var newGroup = entry[entry._description.groupName];\n          groupedObject[destinationKey].addGroupEntries(entry._description.groupDestinationName, newGroup);\n          keysToDelete.push(key);\n        }\n      }\n    }\n    // delete all moved entries that had been collected by their key\n    for (index = 0; index < keysToDelete.length; index += 1) {\n      var keyToDelete = keysToDelete[index];\n      delete groupedObject[keyToDelete];\n    }\n    return groupedObject;\n  }\n\n  /**\n   * Fills in extra \"_comma_separated_values\" properties into the flattened data\n   * for properties that end with an array. E.g. response.hits.hits.tags[0]=\"active\" and response.hits.hits.tags[0]=\"ready\"\n   * will lead to the extra element \"response.hits.hits.tags_comma_separated_values=\"active, ready\".\n   *\n   * @return flattened data with filled in \"_comma_separated_values\" properties\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function fillInArrayValues(flattenedData) {\n    var trailingArrayIndexRegEx = new RegExp(\"\\\\[\\\\d+\\\\]$\", \"gi\");\n    var result = [];\n    var lastArrayProperty = \"\";\n    var lastArrayPropertyValue = \"\";\n\n    flattenedData.filter(function (entry) {\n      if (!entry.name.match(trailingArrayIndexRegEx)) {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        result.push(entry);\n        return;\n      }\n      var propertyNameWithoutTrailingArrayIndex = entry.name.replace(trailingArrayIndexRegEx, \"\");\n      if (lastArrayProperty === propertyNameWithoutTrailingArrayIndex) {\n        lastArrayPropertyValue += \", \" + entry.value;\n      } else {\n        if (lastArrayProperty !== \"\") {\n          result.push({ name: lastArrayProperty + \"_comma_separated_values\", value: lastArrayPropertyValue });\n          lastArrayProperty = \"\";\n        }\n        lastArrayProperty = propertyNameWithoutTrailingArrayIndex;\n        lastArrayPropertyValue = entry.value;\n      }\n      result.push(entry);\n    });\n    return result;\n  }\n\n  function propertiesAsArray(groupedData) {\n    var result = [];\n    var propertyNames = Object.keys(groupedData);\n    for (var propertyIndex = 0; propertyIndex < propertyNames.length; propertyIndex++) {\n      var propertyName = propertyNames[propertyIndex];\n      var propertyValue = groupedData[propertyName];\n      result.push(propertyValue);\n    }\n    return result;\n  }\n\n  /**\n   * Converts described entries (internal data structure) to described fields (external data structure).\n   * Since the structure of a described field is hierarchical, every field needs to be converted\n   * in a recursive manner. The maximum recursion depth is taken as the second parameter.\n   * @param {module:datarestructor.DescribedEntry[]} describedEntries\n   * @param {number} maxRecursionDepth  maximum hierarchy depth\n   * @returns {module:described_field.DescribedDataField[]}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function toDescribedFields(describedEntries, maxRecursionDepth) {\n    var result = [];\n    var index;\n    var describedEntity;\n    for (index = 0; index < describedEntries.length; index += 1) {\n      describedEntity = describedEntries[index];\n      result.push(toDescribedField(describedEntity, 0, maxRecursionDepth));\n    }\n    return result;\n  }\n\n  /**\n   * Converts a internal described entry to a newly created public described field.\n   * Since the structure of a described field is hierarchical, this function is called recursively.\n   * Because the internal described entries may very likely contain cyclic references, the depth of recursion\n   * needs to be limited. Therefore, the current recursion depth is taken as second parameter\n   * and the maximum recursion depth is taken as third parameter.\n   * @param {module:datarestructor.DescribedEntry} entry the internal entry that will be converted\n   * @param {number} recursionDepth current hierarchy recursion depth\n   * @param {number} maxRecursionDepth  maximum hierarchy recursion depth\n   * @returns {module:described_field.DescribedDataField}\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function toDescribedField(entry, recursionDepth, maxRecursionDepth) {\n    var field = new described_field.DescribedDataFieldBuilder()\n      .category(entry.category)\n      .type(entry.type)\n      .abbreviation(entry.abbreviation)\n      .image(entry.image)\n      .index(entry.index)\n      .displayName(entry.displayName)\n      .fieldName(entry.fieldName)\n      .value(entry.value)\n      .build();\n    if (recursionDepth > maxRecursionDepth) {\n      return field;\n    }\n    var fieldGroups = new described_field.DescribedDataFieldGroup(field);\n    forEachGroupEntry(entry, function (groupName, groupEntry) {\n      fieldGroups.addGroupEntry(groupName, toDescribedField(groupEntry, recursionDepth + 1, maxRecursionDepth));\n    });\n    return field;\n  }\n\n  /**\n   * Takes the full qualified original property name and extracts a simple name out of it.\n   *\n   * @callback module:datarestructor.onEntryFoundFunction\n   * @param {string} groupName name of the group where the entry had been found.\n   * @param {module:datarestructor.DescribedEntry} foundEntry the found entry itself.\n   */\n\n  /**\n   * Traverses through all groups and their entries and calls the given function on every found entry\n   * with the group name and the entry itself as parameters.\n   * @param {module:datarestructor.DescribedEntry} rootEntry\n   * @param {module:datarestructor.onEntryFoundFunction} onFoundEntry\n   * @protected\n   * @memberof module:datarestructor.Transform\n   */\n  function forEachGroupEntry(rootEntry, onFoundEntry) {\n    var groupIndex, entryIndex;\n    var groupName, entry;\n    for (groupIndex = 0; groupIndex < rootEntry.groupNames.length; groupIndex += 1) {\n      groupName = rootEntry.groupNames[groupIndex];\n      for (entryIndex = 0; entryIndex < rootEntry[groupName].length; entryIndex += 1) {\n        entry = rootEntry[groupName][entryIndex];\n        onFoundEntry(groupName, entry);\n      }\n    }\n  }\n\n  return Transform;\n})();\n\n/**\n * Main fassade for the data restructor as static function(s).\n * \n * @example \n * var allDescriptions = [];\n * allDescriptions.push(summariesDescription());\n * allDescriptions.push(detailsDescription());\n * var result = datarestructor.Restructor.processJsonUsingDescriptions(jsonData, allDescriptions);\n * @namespace module:datarestructor.Restructor\n */\ndatarestructor.Restructor = {};\n/**\n * Static fassade function for the \"Assembly line\", that takes the jsonData and processes it using all given descriptions in their given order.\n * @param {object} jsonData - parsed JSON data or any other data object\n * @param {module:datarestructor.PropertyStructureDescription[]} descriptions - already grouped entries\n * @param {boolean} debugMode - false=default=off, true=write additional logs for detailed debugging\n * @returns {module:datarestructor.DescribedEntry[]}\n * @memberof module:datarestructor.Restructor\n * @deprecated since v3.1.0, please use \"new datarestructor.Transform(descriptions).processJson(jsonData)\".\n */\ndatarestructor.Restructor.processJsonUsingDescriptions = function(jsonData, descriptions, debugMode) {\n  var restructor = new datarestructor.Transform(descriptions);\n  if (debugMode) {\n    restructor.enableDebugMode();\n  }\n  return restructor.processJson(jsonData);\n};","\"use strict\";\nrequire(\"../../lib/js/polyfills/isArrayPolyfill.js\");\nrequire(\"../../lib/js/polyfills/arrayFilterPolyfill.js\");\nrequire(\"../../lib/js/polyfills/indexOfPolyfill.js\");\nrequire(\"../../lib/js/polyfills/objectKeysPolyfill.js\");\nvar datarestructor = require(\"../../src/js/datarestructor.js\");\nmodule.exports= {datarestructor};\n"]}